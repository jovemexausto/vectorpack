# RFC-0004: Temporal Knowledge — Living Provenance for VectorPack Artifacts

**Status:** Draft  
**Version:** 0.1.0  
**Created:** 2026-02-27  
**Authors:** VectorPack Contributors  
**Depends on:** RFC-0001 v0.3.0, RFC-0002 v0.1.0, RFC-0003 v0.1.0

### Changelog

- **0.1.0** — Initial draft.

---

## Abstract

This document specifies **Temporal Knowledge** — the property that a VectorPack artifact carries not just its current state but a queryable record of how it got there. A temporally-aware pack answers not only *"what do we know?"* but *"what did we know, when did it change, and what changed it?"*

Temporal Knowledge is achieved through three coordinated mechanisms: a **CHANGELOG section** (0x06) in the bundle format (extending RFC-0001 §3.1), a **self-source plugin** (`@vpack/source-self`) that carries history forward across builds, and an **LLM-assisted diff summary output** (`@vpack/output-diff-summary`) that compiles semantically meaningful change descriptions into embedded, queryable chunks.

Together with the deterministic index formats of RFC-0002 and RFC-0003, these mechanisms enable a new distribution primitive: **patch-based pack updates** (`.vpack.patch`), where consumers subscribe to a pack and receive only incremental changes — each carrying its own changelog — rather than downloading full artifacts on every rebuild.

---

## Table of Contents

1. [Motivation](#1-motivation)
2. [Terminology](#2-terminology)
3. [The CHANGELOG Section](#3-the-changelog-section)
4. [The Changelog Chunk Schema](#4-the-changelog-chunk-schema)
5. [The ChunkDiff Type](#5-the-chunkdiff-type)
6. [The Self-Source Plugin](#6-the-self-source-plugin)
7. [The Diff-Summary Output Plugin](#7-the-diff-summary-output-plugin)
8. [History Accumulation and Compression](#8-history-accumulation-and-compression)
9. [The Patch Format](#9-the-patch-format)
10. [The Subscribe Primitive](#10-the-subscribe-primitive)
11. [Query Semantics for Temporal Chunks](#11-query-semantics-for-temporal-chunks)
12. [Registry Protocol Extensions](#12-registry-protocol-extensions)
13. [Manifest Configuration](#13-manifest-configuration)
14. [Security Considerations](#14-security-considerations)
15. [Open Questions](#15-open-questions)

---

## 1. Motivation

Every knowledge base changes over time. Decisions get revised. Processes evolve. Principles are rewritten. The RAG systems built on top of them have no memory of these changes — they serve the current state and discard everything that led to it.

This creates three real problems:

**No audit trail.** *"When did we change our pricing policy?"* cannot be answered from a static knowledge artifact. The answer lived in Notion two versions ago and is now gone.

**No context for current state.** *"Why do we deploy using blue-green?"* might have an answer in a GitHub issue that was resolved eighteen months ago, long since removed from the active documentation. Without history, the rationale is invisible.

**No observable evolution.** Teams cannot ask their knowledge base to reflect on how their thinking has shifted. *"How has our engineering culture changed this year?"* is an answerable question if history is preserved. It is unanswerable if the pack contains only the present.

Temporal Knowledge addresses all three by making a pack's history a first-class, queryable part of the artifact. History is not stored separately as a log — it is embedded alongside content and participates in the same retrieval system. Temporal queries are just queries.

---

## 2. Terminology

| Term | Definition |
|---|---|
| **Temporal Knowledge** | The property of a pack that makes its history queryable, not just its current state |
| **Changelog Chunk** | An embedded, queryable chunk describing what changed in a specific build |
| **ChunkDiff** | A structured record of added, modified, and removed chunks between two builds |
| **Self-Source** | A source plugin (`@vpack/source-self`) that reads changelog chunks from the previous version of the same pack |
| **Diff Summary** | An LLM-generated natural language description of a ChunkDiff, stored as a Changelog Chunk |
| **CHANGELOG section** | Section 0x06 of the bundle format — an ordered, append-only sequence of Changelog Chunks |
| **Patch file** | A `.vpack.patch` artifact containing a ChunkDiff and INDEX PATCH against a specific base version |
| **Subscribe** | The act of receiving incremental patches rather than full artifact downloads |
| **History compression** | Collapsing N Changelog Chunks into a single higher-level summary to bound section growth |
| **TTL** | Time-to-live — a field on Changelog Chunks that causes them to expire after a specified duration |

Terms from RFC-0001, RFC-0002, RFC-0003 apply.

---

## 3. The CHANGELOG Section

The bundle format (RFC-0001 §3.1) is extended with a new optional section:

```
┌─────────────────────────────────┐
│  HEADER (fixed 64 bytes)        │
│  magic: b"VPACK"                │
│  spec_version: u8               │
│  flags: u16  ← bit 0: has_changelog │
│  section_count: u8              │
│  manifest_hash: [u8; 32]        │
├─────────────────────────────────┤
│  SECTION TABLE                  │
│  [ section_id: u8               │
│    offset: u64                  │
│    length: u64                  │
│    checksum: u32 ] × N          │
├─────────────────────────────────┤
│  SECTION: MANIFEST   (0x01)     │
│  SECTION: CHUNKS     (0x02)     │
│  SECTION: VECTORS    (0x03)     │
│  SECTION: INDEX      (0x04)     │
│  SECTION: PROVENANCE (0x05)     │
├─────────────────────────────────┤
│  SECTION: CHANGELOG  (0x06)     │  ← new, optional
│  bincode-encoded                │
│  Vec<ChangelogChunk>            │
│  sorted by built_at asc         │
│  (oldest first)                 │
└─────────────────────────────────┘
```

The CHANGELOG section is **optional**. Packs without it are fully valid. Consumers that do not understand temporal knowledge ignore section 0x06 entirely. The `has_changelog` flag (bit 0 of `flags` in the header) allows consumers to detect the section without seeking.

The CHANGELOG section is **append-only in semantics**. Each build may add new Changelog Chunks; it never removes existing ones except through explicit history compression (§8) or TTL expiration (§8.1). The ordering invariant — `built_at` ascending — must be preserved.

The vectors of Changelog Chunks are stored **within the CHANGELOG section**, not in the VECTORS section (0x03). This keeps the VECTORS section parallel to CHUNKS (0x02) without introducing gaps, and allows consumers to load changelog vectors independently for temporal-only queries.

---

## 4. The Changelog Chunk Schema

A Changelog Chunk is a specialised chunk that describes one build's changes. It is embedded alongside content chunks and participates in semantic search.

```typescript
interface ChangelogChunk {
  // All standard Chunk fields
  id: string                       // deterministic: sha256("changelog:" + pack_name + built_at)
  text: string                     // the LLM-generated natural language summary — this is what gets embedded and queried
  vector: number[]                 // embedding of text, same model as content chunks

  metadata: {
    // Required fields
    chunk_type: 'changelog'        // discriminator — distinguishes from content chunks
    pack_name: string
    pack_version: string           // version this summary describes
    base_version?: string          // version this build was diffed against (undefined for first build)
    built_at: string               // ISO 8601 — when the build ran
    summary_model: string          // which LLM generated the text, e.g. "claude-sonnet-4-6"

    // Diff statistics
    changes_added: number          // count of new chunks
    changes_modified: number       // count of modified chunks
    changes_removed: number        // count of removed chunks
    affected_sources: string[]     // which source plugins contributed changes, e.g. ["@vpack/source-notion"]

    // History management
    ttl_days?: number              // if set, this chunk expires after this many days from built_at
    compressed_from?: string[]     // if this is a compression summary, the IDs of the chunks it replaced
    style: 'daily' | 'weekly' | 'monthly' | 'quarterly'  // granularity of this summary

    // Source attribution (links back to the diff)
    patch_hash?: string            // hash of the .vpack.patch file that produced this change, if distributed via patch

    [key: string]: unknown
  }
}
```

### 4.1 The `text` field is the queryable surface

The `text` of a Changelog Chunk is what gets embedded and retrieved. It must be written in natural language suitable for semantic search — not a structured log, not a list of IDs. A temporal query like *"when did we change our pricing strategy?"* succeeds because the `text` of a Changelog Chunk says *"The pricing strategy was updated: annual enterprise contracts now include a 20% discount. The rationale referenced customer churn from Q3. (Source: Notion / Product Decisions)"* — not *"chunk abc123 modified, chunk def456 added."*

The quality of temporal queries depends entirely on the quality of Changelog Chunk `text`. This is why `@vpack/output-diff-summary` uses an LLM, not a template.

### 4.2 The `chunk_type` discriminator

All standard query operations encounter both content chunks and changelog chunks. The `chunk_type: 'changelog'` field is the universal discriminator. Query consumers can:

- **Include all:** unfiltered queries return both current knowledge and temporal history ranked together. A question like *"what is our pricing strategy?"* naturally surfaces both the current policy and relevant historical changes.
- **Content only:** filter `chunk_type neq 'changelog'` to restrict to current knowledge.
- **History only:** filter `chunk_type eq 'changelog'` for pure temporal queries.
- **Temporal window:** filter by `built_at` range to ask questions about a specific period.

---

## 5. The ChunkDiff Type

`ChunkDiff` is the structured representation of what changed between two builds. It is computed by the pipeline (§6.2 of RFC-0001) and made available to output plugins via `BuildContext`. This RFC promotes it to a first-class type.

```typescript
interface ChunkDiff {
  /** Chunks present in this build that were not present in the previous build. */
  added: EmbeddedChunk[]

  /**
   * Chunks that exist in both builds but whose text content changed.
   * The `before` field carries the previous version's text for LLM summarization.
   * `before` is sourced from the previous artifact's CHUNKS section.
   */
  modified: Array<{
    before: Chunk      // previous version — text only, no vector needed
    after: EmbeddedChunk  // current version — full, with new vector
  }>

  /** Chunk IDs that were present in the previous build but are absent in this one. */
  removed: Array<{
    id: string
    text: string        // preserved from previous build for summarization
    metadata: ChunkMetadata
  }>

  /** ISO 8601 timestamp of the previous build this diff is against. */
  base_built_at?: string

  /** Pack version this diff is against. */
  base_version?: string
}
```

### 5.1 Computing ChunkDiff

ChunkDiff requires access to the previous build's CHUNKS section. The pipeline obtains this from:

1. **Local cache** — `.vpack-cache/previous.vpack` stored alongside the manifest after each successful build. The pipeline reads CHUNKS (0x02) from this file using partial reads (RFC-0001 §3.1). The full artifact is not loaded.
2. **Registry** — if no local cache exists, the pipeline fetches only the CHUNKS section of the previous published version via partial section download (RFC-0001 §11.1). This is a network request, not a full download.
3. **First build** — if neither exists, `ChunkDiff` has all chunks in `added` and empty `modified` and `removed`. No previous base.

The local cache is preferred. A nightly GitHub Actions build always has the previous artifact available as a workflow artifact or cached in R2.

### 5.2 ChunkDiff in BuildContext

`BuildContext` (RFC-0001 §5.8) is extended:

```typescript
export interface BuildContext {
  readonly manifest: PackManifest
  readonly previousBuildHash?: string
  readonly changedChunkIds: Set<string>   // existing field — kept for backward compat
  readonly diff: ChunkDiff               // new — full diff with text, for output plugins
  readonly buildId: string
  readonly dryRun: boolean
}
```

All output plugins receive the full `ChunkDiff` via `ctx.diff`. Plugins that do not use it ignore it. No breaking change.

---

## 6. The Self-Source Plugin

`@vpack/source-self` is a source plugin that reads Changelog Chunks from the previous version of the same pack. It is the mechanism by which temporal history accumulates across builds without content duplication.

```yaml
plugins:
  - kind: source
    use: "@vpack/source-self"
    sections: [changelog]           # which sections to pull from previous build
    # Only 'changelog' is supported in v0.1.0.
    # 'content' is intentionally excluded — it would cause infinite duplication.
```

### 6.1 What source-self does

On each build, `@vpack/source-self` fetches the CHANGELOG section (0x06) of the previous artifact — from the local cache or registry — and yields each `ChangelogChunk` as a `RawDocument`. These documents pass through the pipeline's pre-chunk transformers (where TTL expiration and history compression happen), and are re-embedded alongside the current build's content chunks.

The result: every build carries forward the complete temporal history of the pack, minus any entries expired by TTL or compressed by §8.

### 6.2 The bootstrap problem

The first build has no previous artifact. `@vpack/source-self` yields nothing on first build — this is correct and expected. The first Changelog Chunk is generated by `@vpack/output-diff-summary` after BUILD 1 completes, and is fed into BUILD 2 by `@vpack/source-self`. History always trails one build behind current content. This is semantically correct: the changelog describes what changed *to produce the current state*.

### 6.3 Source fingerprinting

`@vpack/source-self` implements `fingerprint()` by returning the hash of the previous artifact's CHANGELOG section. If no Changelog Chunks changed and no TTL expirations occurred, the fingerprint is identical and the source is skipped by the build cache (RFC-0001 §6.2). History forwarding is zero-cost when nothing expires.

---

## 7. The Diff-Summary Output Plugin

`@vpack/output-diff-summary` is an output plugin that receives the `ChunkDiff` from `BuildContext`, generates an LLM-assisted natural language summary, and writes the result as a `ChangelogChunk` to a designated location — typically `.vpack-cache/next-changelog.json` — where the next build's `@vpack/source-self` will pick it up.

```yaml
plugins:
  - kind: source
    use: "@vpack/source-self"
    sections: [changelog]

  # ... other plugins ...

  - kind: output
    use: "@vpack/output-diff-summary"
    model: claude-sonnet-4-6          # LLM for generating summaries
    api_key: $ANTHROPIC_API_KEY
    style: daily                      # daily | weekly | monthly | quarterly
    max_changes: 15                   # summarise top N most significant changes
    group_by: source_plugin           # group changes by their origin
    audience: team                    # team | technical | executive
    feed_back: true                   # write result for next build's source-self

  - kind: output
    use: "@vpack/output-slack"
    channel: "#knowledge-updates"
    # Reads the summary generated by output-diff-summary above
    # via a shared build-scoped result store
```

### 7.1 The prompt contract

`@vpack/output-diff-summary` sends a structured prompt to the configured LLM. The prompt schema is part of the plugin's public contract — implementors can replace the plugin with any summary generator that honours the `ChangelogChunk` output schema.

The prompt includes:

- The full `ChunkDiff` (added, modified, removed) with text content
- Source attribution from chunk metadata (`source_url`, `source_plugin`)
- The `audience` and `style` config
- Instructions to produce natural language suitable for embedding — no bullet IDs, no raw metadata

The LLM output is the `text` field of the resulting `ChangelogChunk`. It is immediately embedded by the configured embedder plugin and stored in `.vpack-cache/next-changelog.json`.

### 7.2 Summary styles

Different styles produce different granularities of text, appropriate for different TTLs:

| Style | Typical content | Default TTL |
|---|---|---|
| `daily` | Specific changes from today's build | 30 days |
| `weekly` | Aggregated changes from the past week | 90 days |
| `monthly` | Key shifts and themes from the past month | 365 days |
| `quarterly` | Strategic evolution narrative | indefinite |

Quarterly summaries are generated by `@vpack/middleware-compress-history` (§8.2), not by `output-diff-summary` directly.

### 7.3 Downstream outputs

When `@vpack/output-diff-summary` runs before `@vpack/output-slack` (or any other notification output) in the plugin declaration order, the notification outputs can read the generated summary from the build-scoped result store. The Slack message becomes a natural language knowledge update rather than a metrics notification.

This is opt-in. Outputs declared before `output-diff-summary` in the manifest do not have access to the summary.

---

## 8. History Accumulation and Compression

Left unmanaged, the CHANGELOG section grows indefinitely. A pack rebuilt nightly accumulates 365 Changelog Chunks per year. For most packs this is acceptable — Changelog Chunks are small compared to content chunks, and the CHANGELOG section is read independently of CHUNKS and VECTORS. But for long-lived packs or constrained consumers, accumulation must be bounded.

Two mechanisms are provided: **TTL expiration** and **history compression**.

### 8.1 TTL Expiration

A `ChangelogChunk` with `ttl_days` set is considered expired when:

```
current_date > Date.parse(metadata.built_at) + ttl_days * 86400000
```

Expired Changelog Chunks are filtered out by `@vpack/transformer-expire` before re-embedding:

```yaml
plugins:
  - kind: source
    use: "@vpack/source-self"
    sections: [changelog]

  - kind: transformer
    use: "@vpack/transformer-expire"    # drops expired changelog chunks
    # Applies only to chunks where chunk_type === 'changelog'
    # Content chunks are never affected
```

The `@vpack/output-diff-summary` plugin sets `ttl_days` based on the `style` config (§7.2 table). Operators can override with an explicit `ttl_days` field.

### 8.2 History Compression

When TTL removes granular daily entries, the detailed record is lost. Compression preserves the signal at reduced resolution. `@vpack/middleware-compress-history` runs as a build middleware and, when triggered, collapses N Changelog Chunks into a single higher-level summary:

```yaml
plugins:
  - kind: middleware
    use: "@vpack/middleware-compress-history"
    compress_after_days: 30     # collapse daily entries older than 30 days into weekly
    weekly_after_days: 90       # collapse weekly entries older than 90 days into monthly
    model: claude-sonnet-4-6    # LLM for generating compression summaries
```

The compression summary is itself a `ChangelogChunk` with:
- `style: 'weekly'` or `'monthly'` or `'quarterly'`
- `compressed_from: [id1, id2, ...]` — the IDs of the collapsed chunks
- Its own `ttl_days` appropriate to the new granularity

The original granular chunks are removed from the CHANGELOG section. The information is preserved — just at lower resolution. This mirrors how human memory actually works: recent events in detail, older events as patterns and themes.

### 8.3 Accumulation bounds in practice

For a nightly-rebuilding pack with the default compression policy:

```
Days 1–30:   30 daily changelog chunks                    (~30 entries)
Days 31–90:  4 weekly summaries + current daily window    (~34 entries)
Days 91–365: 3 monthly summaries + current weekly window  (~37 entries)
Year 2+:     4 quarterly summaries + current monthly      (~40 entries)
```

A pack with years of history stabilises at roughly 40–60 Changelog Chunks. Each chunk is typically 200–400 tokens of text plus its vector. At 768 dimensions (f32), that is roughly 3KB per chunk — well under 200KB total for the CHANGELOG section at steady state.

---

## 9. The Patch Format

The `.vpack.patch` file is a new artifact type enabled by the deterministic index formats of RFC-0002 and RFC-0003. It carries the delta between two specific versions of a pack, including the Changelog Chunk generated for that delta.

### 9.1 Patch file structure

```
┌─────────────────────────────────────┐
│  PATCH HEADER (fixed 48 bytes)      │
│  magic: b"VPATCH"                   │
│  spec_version: u8                   │
│  flags: u16                         │
│  base_version_hash: [u8; 32]        │  hash of the artifact being patched
│  result_version_hash: [u8; 32]      │  hash of the artifact after applying
├─────────────────────────────────────┤
│  SECTION: CHUNK DIFF (0x01)         │
│  added:    Vec<EmbeddedChunk>       │
│  modified: Vec<(old_id, EmbeddedChunk)> │
│  removed:  Vec<chunk_id>            │
├─────────────────────────────────────┤
│  SECTION: INDEX PATCH (0x02)        │  only present when index type is IVF-PQ (RFC-0003)
│  affected_clusters: Vec<u32>        │
│  cluster_deltas:    Vec<ClusterDelta>│  sorted inverted list updates, deterministic
├─────────────────────────────────────┤
│  SECTION: CHANGELOG ENTRY (0x03)   │
│  entry: ChangelogChunk              │  the summary chunk for this patch
│                                     │  pre-embedded, ready for direct insertion
└─────────────────────────────────────┘
```

### 9.2 Why `base_version_hash` is a hard requirement

A patch is only valid against exactly one base. The consumer verifies `base_version_hash` against their local artifact before applying anything. Mismatch is a hard error — the consumer falls back to a full pull. This prevents silent corruption from out-of-order patch application.

After applying, the consumer verifies the local artifact's hash matches `result_version_hash`. If it does not, the patch application is rolled back and a full pull is initiated. The patch mechanism is safe to interrupt — it never leaves the local artifact in a partially applied state.

### 9.3 Patch application is atomic

The consumer applies a patch in this order, treating the operation as a transaction:

```
1. Verify base_version_hash matches local artifact
2. Write updated CHUNKS section to a staging buffer
3. Write updated VECTORS section to a staging buffer
4. Apply INDEX PATCH to a staging buffer (IVF-PQ) or rebuild INDEX (HNSW)
5. Append CHANGELOG ENTRY to CHANGELOG section staging buffer
6. Verify result_version_hash against staged result
7. Atomically swap staging buffers into the live artifact
8. On any failure: discard staging, fall back to full pull
```

Steps 1–6 happen in memory or in a staging file. Step 7 is a single file rename. The live artifact is never in a partial state.

### 9.4 INDEX PATCH and HNSW

RFC-0002 (Det-HNSW) enables deterministic verification of a patched artifact but does not enable efficient patching — HNSW graph modifications after node insertion are expensive. When the index type is HNSW, the INDEX PATCH section (0x02) is absent and the INDEX section is rebuilt in full from the staged CHUNKS + VECTORS. The patch still carries the CHUNK DIFF and CHANGELOG ENTRY, which are cheap. Only the INDEX rebuild is expensive.

RFC-0003 (Det-IVF-PQ) enables efficient INDEX PATCH because inverted lists are cluster-local. A patch touching 5% of chunks typically touches 10–20% of clusters. Only affected clusters are serialized in the patch. The consumer updates only those clusters in-place.

Operators choosing IVF-PQ get efficient patch application at the cost of slightly lower query recall. The trade-off is documented in RFC-0003 §8.

---

## 10. The Subscribe Primitive

**Subscribe** is a high-level operation built on top of patches. A consumer subscribes to a pack and receives patches as they are published, rather than downloading full artifacts.

```bash
# Subscribe — download initial artifact, then receive patches automatically
vpack subscribe @acme/knowledge

# Check for and apply new patches
vpack update @acme/knowledge

# Unsubscribe — stop receiving patches, keep current artifact
vpack unsubscribe @acme/knowledge
```

### 10.1 Subscribe state

Subscription state is stored in `~/.vpackrc`:

```yaml
subscriptions:
  "@acme/knowledge":
    current_version: "3.14.0"
    current_hash: "sha256:abc..."
    subscribed_at: "2026-02-27T00:00:00Z"
    registry: "https://registry.vpack.dev"
    index_type: "ivf-pq"     # determines patch efficiency
```

### 10.2 Push vs. pull

The registry supports two delivery models:

**Pull** — `vpack update` polls the registry for new patches since `current_version`. Returns a list of available patches in order. The consumer applies them sequentially. Suitable for scheduled updates (cron, GitHub Actions).

**Push** — the registry sends a webhook or SSE notification when a new patch is published. The consumer's local `vpack` daemon (or a webhook receiver) applies the patch automatically. Suitable for always-current local knowledge bases.

### 10.3 Catch-up

If a consumer misses multiple patches (e.g., offline for a week), the registry provides a **catch-up bundle**: the full artifact at the latest version. The consumer discards patches and downloads the full artifact. This is always safe — full artifacts are always available in the registry, regardless of patch history.

Catch-up is triggered automatically when:
- The gap between `current_version` and `latest` exceeds a registry-configured threshold (default: 30 patches)
- Any patch in the sequence is missing or fails verification
- The consumer explicitly requests a full pull

---

## 11. Query Semantics for Temporal Chunks

Temporal queries are regular queries. No new query operations are required. The `chunk_type` discriminator and `built_at` metadata field are sufficient to implement all temporal query patterns using the existing `MetadataFilter` interface (RFC-0001 §10).

### 11.1 Query patterns

```typescript
// Current knowledge only — exclude changelog chunks
await index.query("what is our pricing strategy?", {
  filter: { field: "chunk_type", op: "neq", value: "changelog" }
})

// History only — pure temporal query
await index.query("how has our pricing strategy changed?", {
  filter: { field: "chunk_type", op: "eq", value: "changelog" }
})

// Mixed — current knowledge + relevant history ranked together
// (no filter — this is the default and usually the most useful)
await index.query("what is our pricing strategy?")

// Temporal window — what changed in Q1 2026?
await index.query("pricing changes", {
  filter: {
    field: "built_at",
    op: "gte",
    value: "2026-01-01T00:00:00Z"
  }
})

// Source-specific history — what changed in our Notion docs?
await index.query("recent changes", {
  filter: {
    field: "affected_sources",
    op: "in",
    value: ["@vpack/source-notion"]
  }
})
```

### 11.2 Temporal context in LLM responses

When a query returns a mix of content chunks and changelog chunks, the LLM generating a response has access to both the current state and the history of how it got there. This enables answers like:

> *"Our current pricing policy offers a 20% discount for annual enterprise contracts. This was introduced in February 2026, when it replaced the previous flat-rate model. The change was driven by Q3 2025 churn analysis. (Sources: Product Decisions / Notion, Change log Feb 14 2026)"*

No special retrieval logic is needed. The changelog chunk's text carries the historical context and is ranked alongside the content chunk by the same cosine similarity.

### 11.3 Score weighting for temporal chunks

By default, changelog chunks compete equally with content chunks in retrieval. For queries where current knowledge should dominate, operators can apply a recency boost:

```typescript
// Available in @vpack/client v0.2.0+
await index.query("pricing strategy", {
  temporalWeight: 0.3  // reduce score of changelog chunks by 30%
})
```

This is a post-retrieval score adjustment, not a change to HNSW traversal. It is not part of the core engine interface — it is a client-side feature of `@vpack/client`.

---

## 12. Registry Protocol Extensions

### 12.1 Patch publication

When a pack is rebuilt and a `.vpack.patch` is generated, the output plugin `@vpack/output-registry` publishes both the full artifact and the patch:

```
POST /v1/packs/{scope}/{name}/{version}/patch
Body: binary .vpack.patch file
Headers: Content-Type: application/vpack-patch
Response: { patch_hash: "sha256:...", base_version: "3.13.0", result_version: "3.14.0" }
```

The registry stores patches content-addressed, like all other blobs.

### 12.2 Patch discovery

```
GET /v1/packs/{scope}/{name}/patches?since={version}
Response: {
  patches: [
    { from: "3.12.0", to: "3.13.0", patch_hash: "sha256:...", size_bytes: 42000 },
    { from: "3.13.0", to: "3.14.0", patch_hash: "sha256:...", size_bytes: 31000 }
  ],
  catch_up_available: false
}
```

### 12.3 Patch download

```
GET /v1/packs/{scope}/{name}/patches/{from}/{to}
Response: binary .vpack.patch file
```

### 12.4 Changelog query endpoint

For `verified` packs, the registry exposes a changelog-only query endpoint. This allows consumers to retrieve temporal history without downloading the pack:

```
POST /v1/packs/{scope}/{name}/{version}/changelog/query
Body: { "query": "how has pricing changed?", "top_k": 5 }
Response: {
  "results": [ { "chunk": { "chunk_type": "changelog", "text": "...", ... }, "score": 0.89 } ],
  "model": "nomic-embed-text"
}
```

---

## 13. Manifest Configuration

A temporally-aware pack manifest includes `@vpack/source-self` as a source and `@vpack/output-diff-summary` as an output. Other plugins are unchanged.

```yaml
vpack: "1.0"
name: "@acme/knowledge"
version: "4.0.0"

plugins:
  # ── History forwarding ───────────────────────────────────────────
  # Must be declared first — history is part of the source stream
  - kind: source
    use: "@vpack/source-self"
    sections: [changelog]

  # ── Content sources ──────────────────────────────────────────────
  - kind: source
    use: "@vpack/source-notion"
    database_id: abc123

  - kind: source
    use: "@vpack/source-github"
    repo: acme/core
    include: ["docs/**"]

  # ── Pre-chunk transformers ───────────────────────────────────────
  - kind: transformer
    use: "@vpack/transformer-markdown-clean"

  - kind: transformer
    use: "@vpack/transformer-pii"
    redact: [email, phone]

  - kind: transformer
    use: "@vpack/transformer-expire"   # drops changelog chunks past TTL
    # only affects chunk_type === 'changelog'

  # ── History compression (middleware) ─────────────────────────────
  - kind: middleware
    use: "@vpack/middleware-compress-history"
    compress_after_days: 30
    weekly_after_days: 90
    model: claude-sonnet-4-6

  # ── Chunker ──────────────────────────────────────────────────────
  - kind: chunker
    use: "@vpack/chunker-semantic"
    size: 512
    overlap: 64

  # ── Post-chunk transformers ──────────────────────────────────────
  - kind: transformer
    use: "@vpack/transformer-dedup"
    threshold: 0.98

  # ── Embedder ─────────────────────────────────────────────────────
  - kind: embedder
    use: "@vpack/embedder-local"
    model: nomic-embed-text
    model_hash: sha256:abc123
    dimensions: 768

  # ── Outputs ──────────────────────────────────────────────────────
  - kind: output
    use: "@vpack/output-diff-summary"   # must run before notification outputs
    model: claude-sonnet-4-6
    api_key: $ANTHROPIC_API_KEY
    style: daily
    max_changes: 15
    audience: team
    feed_back: true                     # write changelog chunk for next build

  - kind: output
    use: "@vpack/output-registry"
    ref: "@acme/knowledge:auto"
    publish_patch: true                 # also publish .vpack.patch

  - kind: output
    use: "@vpack/output-slack"
    channel: "#knowledge-updates"
    # reads summary from output-diff-summary above
```

### 13.1 Minimal temporal configuration

For a pack that only wants history without Slack integration or patch distribution:

```yaml
plugins:
  - kind: source
    use: "@vpack/source-self"
    sections: [changelog]

  # ... content sources, chunker, embedder ...

  - kind: output
    use: "@vpack/output-diff-summary"
    model: claude-sonnet-4-6
    api_key: $ANTHROPIC_API_KEY
    feed_back: true
```

Two plugin declarations — source-self and output-diff-summary — are all that is required to make a pack temporally aware.

---

## 14. Security Considerations

**Changelog Chunk trust.** Changelog Chunks are generated by an LLM (`output-diff-summary`). They are not authoritative records of what changed — the `ChunkDiff` is. The Changelog Chunk's `text` is an interpretation for human and retrieval consumption. Consumers requiring authoritative change records should use `vpack diff` or the patch's CHUNK DIFF section directly, not the changelog text.

**LLM API keys in output plugins.** The `api_key` field in `output-diff-summary` must use environment variable references (`$ANTHROPIC_API_KEY`), never inline values. The manifest is committed to version control. This is a convention enforced by the manifest validator with a warning.

**Patch verification is mandatory.** Consumers must verify `base_version_hash` before applying any patch. The CLI enforces this. SDK consumers that bypass this check accept the risk of corrupting their local artifact.

**Source-self scope is restricted.** `@vpack/source-self` may only read the `changelog` section of the previous artifact of the same pack (same `name` field). It cannot read arbitrary packs' sections. This prevents cross-pack data leakage in shared registry environments.

**Changelog PII.** `output-diff-summary` receives the full text of all changed chunks, including any content that passed through `@vpack/transformer-pii`. If PII filtering is declared before the chunker (correct placement), PII is removed from chunk text before it reaches `output-diff-summary`. Operators are responsible for verifying this ordering.

**History expiry is not deletion.** TTL expiration removes a Changelog Chunk from future builds. It does not delete it from previously published artifacts. Artifacts published to the registry are immutable. If a Changelog Chunk contained sensitive information, that artifact must be yanked and its consumers must be notified.

---

## 15. Open Questions

**Q1: Multi-pack temporal queries.** If a team maintains separate `@acme/engineering` and `@acme/product` packs, there is no cross-pack temporal query. Should the `vpack merge` command carry CHANGELOG sections from both input packs, merging them by `built_at` order?

**Q2: Changelog chunk embedder.** Changelog Chunks are currently embedded by the same embedder as content chunks. A temporal-specialist embedding model might produce better retrieval for history-flavoured queries. Is per-section embedder configuration worth the complexity?

**Q3: Authoritative diff access in SDK.** Should `@vpack/client` expose a typed `getDiff(fromVersion, toVersion)` method that reads ChunkDiff data from `.vpack.patch` files directly, separate from the semantic query interface?

**Q4: Patch chain limits.** How many patches can be chained before the registry forces a full catch-up? The default of 30 is a guess. What is the right value, and should it be configurable per pack?

**Q5: Changelog granularity for first-time summarizers.** The first `output-diff-summary` run on a large pack sees thousands of "added" chunks — everything is new. The summary will be enormous and un-useful. Should the first build produce no changelog entry, or a special "initial corpus" summary with different prompt framing?

**Q6: LLM summary determinism.** Changelog Chunk `text` is LLM-generated and therefore non-deterministic. Two identical builds will produce different `text` and hence different `vector`, breaking the reproducibility guarantee (RFC-0001 §4.3) for the CHANGELOG section. The `id` field (hash of pack_name + built_at) is still deterministic, but the content is not. This is an acceptable trade-off — the CHANGELOG section is explicitly informational — but it must be documented clearly. Should the reproducibility guarantee exclude CHANGELOG from its scope?

---

*This RFC is a living document. Discussion and amendments welcome via GitHub Issues and Pull Requests.*

*VectorPack is an open specification. Implementations are not required to be affiliated with the core project.*