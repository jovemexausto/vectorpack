# RFC-0007: Patch-Based Pack Updates and Delta Sync

**Status:** Draft  
**Version:** 0.1.0  
**Created:** 2026-02-28  
**Authors:** VectorPack Contributors  
**Depends on:** RFC-0001 v0.3.0, RFC-0003 v0.1.0  
**Supersedes (partial):** RFC-0002 (Det-HNSW) — deprecated for patch-capable packs, see §2.1  
**Referenced by:** RFC-0004 v0.2.0 (Temporal Knowledge)

### Changelog

- **0.1.0** — Initial draft. Formally deprecates Det-HNSW in favour of Det-IVF-PQ as the mandatory index format for patch-capable packs. Specifies the complete `.vpack.patch` binary format, producer algorithm, atomic consumer application algorithm with rollback, registry protocol extensions, subscribe/update primitives, and catch-up mechanism.

---

## Abstract

This document specifies **patch-based pack updates** — the mechanism by which VectorPack consumers receive incremental changes to a pack rather than downloading the full artifact on every rebuild. A `.vpack.patch` file carries the exact delta between two specific versions: a structured chunk diff, an optional index patch enabling in-place index updates proportional to the change rate, and an optional changelog entry (RFC-0004). Consumers apply patches atomically with cryptographic verification and roll back safely on any failure.

**Det-IVF-PQ (RFC-0003) is the mandatory index format for patch-capable packs.** Det-HNSW (RFC-0002) is formally deprecated for this use case: HNSW is a globally connected graph where small corpus changes trigger full graph rebuilds, producing INDEX sections that are byte-different in nearly every byte — there is no meaningful index delta to send. IVF-PQ's cluster-local structure makes index patches proportional to the change rate. Det-HNSW remains supported for all non-patch operations.

---

## Table of Contents

1. [Motivation](#1-motivation)
2. [Design Decisions](#2-design-decisions)
3. [Terminology](#3-terminology)
4. [Prerequisites](#4-prerequisites)
5. [The Patch File Format](#5-the-patch-file-format)
6. [Producer Algorithm](#6-producer-algorithm)
7. [Consumer Application Algorithm](#7-consumer-application-algorithm)
8. [Index Patch — IVF-PQ Cluster Deltas](#8-index-patch--ivf-pq-cluster-deltas)
9. [Codebook Stability Invariant](#9-codebook-stability-invariant)
10. [Registry Protocol Extensions](#10-registry-protocol-extensions)
11. [The Subscribe Primitive](#11-the-subscribe-primitive)
12. [The Update Primitive](#12-the-update-primitive)
13. [Catch-Up](#13-catch-up)
14. [Interaction with Temporal Knowledge (RFC-0004)](#14-interaction-with-temporal-knowledge-rfc-0004)
15. [CLI Reference](#15-cli-reference)
16. [Security Considerations](#16-security-considerations)
17. [Backward Compatibility](#17-backward-compatibility)
18. [Open Questions](#18-open-questions)

---

## 1. Motivation

Every VectorPack rebuild today produces a complete artifact. A nightly rebuild of a 50MB pack transfers 50MB to every consumer — even if only 3% of source content changed. For packs distributed to many consumers or rebuilt multiple times per day, this is a real cost.

The problem compounds with Temporal Knowledge (RFC-0004): packs that carry a queryable history of their own evolution need consumers to stay current. A consumer who pulls the full artifact weekly misses granular daily changelog entries.

Patch-based distribution solves both:

**Bandwidth proportional to change rate.** A 3%-changed pack produces a patch roughly 3% of the full artifact size. Consumers who were current download almost nothing.

**History without gaps.** Each patch carries its own CHANGELOG ENTRY (RFC-0004 §9.1). A consumer who applies every patch accumulates a complete, gap-free history.

**Push-compatible.** Patches are small enough to deliver via webhook or SSE. Consumers can maintain a near-real-time view of a knowledge base.

---

## 2. Design Decisions

### 2.1 Det-HNSW is deprecated for patch distribution

RFC-0002 (Det-HNSW) makes the INDEX section byte-identical across independent builds of the same content. This was initially proposed as the foundation for patch verification.

Det-HNSW is insufficient for efficient patch distribution for a fundamental structural reason: **HNSW is a globally connected graph**. Adding or removing a node requires edge changes throughout the graph. A small source change triggers a full graph rebuild. The resulting INDEX section is deterministic and verifiable — but it differs from the base INDEX in nearly every byte. There is no meaningful cluster of bytes to isolate as a "patch." The consumer must rebuild the entire INDEX from the patched CHUNKS and VECTORS, at the same cost as a full build.

Det-IVF-PQ (RFC-0003) does not have this property. Inverted lists are **cluster-local**: adding a vector appends it to one cluster's list; removing a vector deletes it from one cluster's list. A 3%-changed corpus touches approximately 3–6% of clusters. The remaining 94–97% of clusters are byte-identical between base and result. Only affected clusters need to be transmitted.

**This RFC formally deprecates Det-HNSW for patch-capable packs.** Packs with `publish_patch: true` must use `index.type: ivf-pq`. The manifest validator emits a hard error otherwise. Packs using Det-HNSW remain fully supported for all non-patch operations — build, query, push, pull, verify. The deprecation is scoped strictly to patch distribution.

### 2.2 The codebook is the fixed point

IVF-PQ requires a codebook — cluster centroids computed from the initial corpus. The codebook is fixed at first build and reused on every subsequent build. This is what makes cluster assignments stable across builds and therefore makes cluster-local patching possible. A codebook change forces a catch-up cycle. Operators must treat IVF-PQ parameter changes (`nlist`, `m`, `bits`) as breaking changes equivalent to changing the embedding model.

### 2.3 Patch application is atomic

A patch is either fully applied or not applied at all. All changes are staged in memory or a temporary file. The result hash is verified. A single atomic rename replaces the live artifact. On any failure the staging buffer is discarded and the consumer falls back to catch-up.

### 2.4 Patches are single-hop

A patch encodes the delta from exactly one base version to exactly one result version. Sequential application reaches arbitrary versions. There is no multi-hop patch format.

---

## 3. Terminology

| Term | Definition |
|---|---|
| **Patch** | A `.vpack.patch` file encoding the delta from a specific base to a specific result version |
| **Base artifact** | The `.vpack` file a patch is applied against — identified by `base_artifact_hash` |
| **Result artifact** | The `.vpack` file produced by applying the patch — hash must match `result_artifact_hash` |
| **CHUNK DIFF** | Section 0x01 of a patch — added, modified, and removed chunks with text and vectors |
| **INDEX PATCH** | Section 0x02 of a patch — replacement inverted lists for affected IVF-PQ clusters |
| **CHANGELOG ENTRY** | Section 0x03 of a patch — a pre-embedded Changelog Chunk (RFC-0004) |
| **Codebook** | IVF + PQ centroids fixed at first build — see §9 |
| **Cluster delta** | The complete replacement inverted list for one affected cluster |
| **Catch-up** | Downloading the full artifact when patch chain application is not practical — see §13 |
| **Subscribe** | Registering to receive patches for a pack as they are published — see §11 |
| **Patch chain** | The ordered sequence of patches connecting a pack's version history |

Terms from RFC-0001, RFC-0003, RFC-0004 apply.

---

## 4. Prerequisites

A pack is **patch-capable** when all of the following are true:

1. `index.type: ivf-pq` is declared in the manifest.
2. A previous build's artifact is available for computing the diff.
3. The IVF-PQ codebook is stable (§9) — `nlist`, `m`, and `bits` unchanged from previous version.
4. `publish_patch: true` is set in the `@vpack/output-registry` plugin config.

The manifest validator emits a hard error if `publish_patch: true` is set without `index.type: ivf-pq`.

---

## 5. The Patch File Format

A `.vpack.patch` is a distinct binary format, not a `.vpack` file. It uses a different magic sequence and cannot be confused with a full artifact.

### 5.1 File layout

```
┌─────────────────────────────────────────┐
│  PATCH HEADER (fixed 80 bytes)          │
│  magic:                b"VPATCH\0"      │  7 bytes + 1 null
│  spec_version:         u8               │
│  flags:                u16              │
│    bit 0: has_index_patch               │  IVF-PQ INDEX PATCH present
│    bit 1: has_changelog_entry           │  RFC-0004 CHANGELOG ENTRY present
│    bit 2: codebook_changed              │  codebook rebuilt — catch-up required
│  section_count:        u8               │
│  base_artifact_hash:   [u8; 32]         │  sha256 of the full base .vpack file
│  result_artifact_hash: [u8; 32]         │  sha256 of the full result .vpack file
│  base_version:         [u8; 32]         │  null-padded UTF-8 semver
│  result_version:       [u8; 32]         │  null-padded UTF-8 semver
├─────────────────────────────────────────┤
│  SECTION TABLE                          │
│  [ section_id: u8                       │
│    offset:     u64                      │
│    length:     u64                      │
│    checksum:   u32  ] × section_count   │
├─────────────────────────────────────────┤
│  SECTION: CHUNK DIFF       (0x01)       │  required
│  SECTION: INDEX PATCH      (0x02)       │  optional — IVF-PQ only
│  SECTION: CHANGELOG ENTRY  (0x03)       │  optional — RFC-0004
└─────────────────────────────────────────┘
```

`base_artifact_hash` and `result_artifact_hash` are SHA-256 hashes of the **complete** `.vpack` files — all sections, header included. They are the cryptographic anchors. A consumer cannot apply a patch to the wrong base. After application, corruption is immediately detectable.

### 5.2 Flags

| Bit | Name | Meaning |
|---|---|---|
| 0 | `has_index_patch` | SECTION 0x02 is present; consumer applies cluster deltas |
| 1 | `has_changelog_entry` | SECTION 0x03 is present; consumer appends to CHANGELOG section |
| 2 | `codebook_changed` | Codebook was rebuilt; this patch cannot be applied; consumer must catch up |

When `codebook_changed` is set, sections 0x02 and 0x03 are absent. The CHUNK DIFF (0x01) may be present for informational purposes but MUST NOT be applied. The consumer must perform catch-up.

### 5.3 CHUNK DIFF section (0x01)

```typescript
interface ChunkDiffSection {
  added: EmbeddedChunk[]

  modified: Array<{
    old_id: string        // chunk ID in the base artifact
    chunk: EmbeddedChunk  // new chunk with updated text and vector
    before_text: string   // text of old chunk — for RFC-0004 output-diff-summary
                          // consumers not implementing RFC-0004 may ignore this field
  }>

  removed: Array<{
    id: string
    text: string          // preserved for RFC-0004 — consumers may ignore
    metadata: ChunkMetadata
  }>
}
```

The CHUNK DIFF section is always present. `before_text` on modified chunks has PII implications — see §16.2.

### 5.4 INDEX PATCH section (0x02)

Present only when `flags.has_index_patch = true`. Carries complete replacement inverted lists for all affected clusters.

```typescript
interface IndexPatchSection {
  // Parallel arrays: affected_cluster_ids[i] is replaced by affected_cluster_lists[i]
  affected_cluster_ids: u32[]

  affected_cluster_lists: Array<Array<{
    node_id: u64   // derived from chunk ID hash
    pq_code: u8[]  // length = m (from index config)
  }>>

  total_clusters: u32    // for consumer validation — must match local index

  // SHA-256 of the serialized codebook from the result artifact's INDEX section.
  // Consumer verifies this matches their local codebook before applying.
  codebook_hash: [u8; 32]
}
```

### 5.5 CHANGELOG ENTRY section (0x03)

Present only when `flags.has_changelog_entry = true`.

```typescript
interface ChangelogEntrySection {
  chunk: ChangelogChunk  // fully specified in RFC-0004 §4
                         // pre-embedded by producer — consumer appends as-is
}
```

`ChangelogChunk.metadata.patch_hash` is set to the SHA-256 of this patch file, creating a verifiable link between history entry and patch.

---

## 6. Producer Algorithm

Runs as part of `vpack build` when `publish_patch: true` is set, after all output plugins complete.

```
PRECONDITIONS:
  index.type == ivf-pq
  previous artifact available (local cache or registry)
  codebook is stable (§9) — or codebook_changed will be set

1. Load previous artifact's CHUNKS section (0x02)
   From .vpack-cache/previous.vpack (partial read) if available,
   else: GET /v1/packs/{scope}/{name}/{prev_version}/section/0x02

2. Check codebook stability
   Compare sha256(current codebook) vs sha256(previous artifact's codebook)
   IF mismatch: set flags.codebook_changed = true, GOTO step 9 (emit patch without index)

3. Compute ChunkDiff
   Compare current CHUNKS with previous CHUNKS by chunk ID
   Populate added, modified (with before_text), removed

4. Identify affected IVF-PQ clusters
   For each added chunk:    affected_clusters += cluster(chunk.vector)
   For each modified chunk: affected_clusters += cluster(new.vector)
                            affected_clusters += cluster(old.vector)  // may differ
   For each removed chunk:  affected_clusters += cluster(chunk.vector)

5. Serialize CHUNK DIFF section (0x01)

6. Serialize INDEX PATCH section (0x02)
   For each cluster in affected_clusters:
     Read complete inverted list from current artifact's INDEX section
     Sort by node_id asc (canonical order — RFC-0003 §4.3)
     Include as cluster delta
   Set codebook_hash = sha256(current codebook bytes)

7. Read CHANGELOG ENTRY from .vpack-cache/next-changelog.json (if present)
   Produced by @vpack/output-diff-summary in the same build
   Serialize as CHANGELOG ENTRY section (0x03) if present

8. Compute base_artifact_hash = sha256(previous artifact bytes)
   Compute result_artifact_hash = sha256(current artifact bytes)

9. Write .vpack.patch:
   PATCH HEADER with flags set appropriately
   SECTION TABLE
   CHUNK DIFF (0x01)
   INDEX PATCH (0x02) if codebook stable
   CHANGELOG ENTRY (0x03) if present

10. Publish patch to registry: POST /v1/packs/{scope}/{name}/patches
```

---

## 7. Consumer Application Algorithm

The consumer applies a patch atomically. The live artifact is never in a partial state.

```
PRECONDITIONS:
  Consumer has local .vpack artifact
  sha256(local_artifact) has been verified against subscription state

IF patch.flags.codebook_changed:
  EMIT "Codebook changed in {result_version}. Performing catch-up."
  GOTO §13

1. VERIFY BASE
   IF sha256(local_artifact) != patch.base_artifact_hash:
     EMIT "Base hash mismatch. Performing catch-up."
     GOTO §13

2. READ all sections of local artifact into staging buffers

3. APPLY CHUNK DIFF to CHUNKS (0x02) and VECTORS (0x03) staging buffers:
   a. Remove entries for removed chunk IDs
   b. Replace entries for modified chunk old_ids with new EmbeddedChunk data
   c. Append added EmbeddedChunks
   d. Sort by chunk ID asc (deterministic order)

4. IF flags.has_index_patch:
   APPLY INDEX PATCH (0x02) to INDEX (0x04) staging buffer:
     a. Verify codebook_hash matches local codebook
        IF mismatch: EMIT error, GOTO §13
     b. Verify total_clusters matches local index cluster count
        IF mismatch: EMIT error, GOTO §13
     c. For each (cluster_id, replacement_list): replace list in staging buffer
     d. All other clusters remain unchanged

5. UPDATE PROVENANCE (0x05) staging buffer:
   Append: { built_at: result_built_at, version: result_version,
             patch_applied_from: base_version }

6. IF flags.has_changelog_entry AND RFC-0004 implemented:
   APPEND ChangelogChunk to CHANGELOG (0x06) staging buffer

7. UPDATE HEADER staging buffer:
   Update section_count, flags, SECTION TABLE offsets and lengths

8. SERIALIZE staged artifact to a temporary file

9. VERIFY RESULT
   IF sha256(temporary_file) != patch.result_artifact_hash:
     EMIT "Result hash mismatch. Rolling back."
     DELETE temporary file
     GOTO §13

10. ATOMIC SWAP
    rename(temporary_file, live_artifact_path)
    (Single syscall — atomic on POSIX and Windows via MoveFileEx)

11. UPDATE ~/.vpackrc subscription state:
    current_version = result_version
    current_hash = result_artifact_hash
```

### 7.1 Failure modes

| Failure point | Action |
|---|---|
| Base hash mismatch (step 1) | Catch-up |
| Codebook hash mismatch (step 4a) | Catch-up |
| Cluster count mismatch (step 4b) | Catch-up |
| Result hash mismatch (step 9) | Delete staging, catch-up |
| Disk full during staging (step 8) | Delete staging, retry later |
| Process killed during rename (step 10) | Either old or new artifact is live — both are valid |

The live artifact is valid at every moment. Step 10 is the only moment state changes, and it is atomic.

---

## 8. Index Patch — IVF-PQ Cluster Deltas

### 8.1 Cluster assignment for modified chunks

A modified chunk may change cluster because its vector changed. The producer handles both clusters:

```
modified chunk m:
  old_cluster = assign(m.old_vector, codebook)
  new_cluster = assign(m.new_vector, codebook)

  affected_clusters += old_cluster   // remove from old (or update if same)
  affected_clusters += new_cluster   // add to new
```

The INDEX PATCH carries the complete replacement list for each affected cluster. The consumer replaces lists wholesale — it does not need to know which entries within a list changed.

### 8.2 Patch size analysis

For a pack with `nlist` clusters, N total chunks, and change rate `r`:

```
Expected affected clusters ≈ nlist × (1 − (1 − r)^(N/nlist))
```

Example: nlist=4096, N=100k, r=0.05 (5% changed):
- Expected affected clusters ≈ 714 of 4096 (~17%)
- Average entries per affected cluster ≈ 7 changed chunks per cluster
- At ~10 bytes per entry (u64 + 2-byte PQ code): 714 × 70 × 10 ≈ 500KB INDEX PATCH
- Full INDEX section: ~10MB for 100k chunks
- **INDEX PATCH is ~5% of full INDEX — matching the change rate**

Increasing `nlist` reduces average cluster size, reducing the number of entries per cluster delta. Operators with high rebuild frequency and large corpora should tune `nlist` upward to minimize patch size.

### 8.3 Sorting invariant

Every inverted list in INDEX PATCH is sorted by `node_id` ascending — the canonical order from RFC-0003 §4.3. The consumer validates this invariant after applying each cluster replacement. An unsorted list is a producer error; the consumer should reject the patch and trigger catch-up.

---

## 9. Codebook Stability Invariant

> *The IVF codebook (centroids) and PQ codebooks (sub-codebooks) of a pack MUST NOT change between consecutive versions unless `nlist`, `m`, or `bits` in the manifest index configuration changes.*

### 9.1 Why this invariant enables patching

When the codebook is stable, a vector that was assigned to cluster 42 in version N is still assigned to cluster 42 in version N+1 (if the chunk was unchanged). The consumer's existing cluster lists for unchanged chunks are still correct. Only clusters containing changed chunks need to be replaced.

Without this invariant, every vector could be reassigned to a different cluster on every build. All cluster lists would differ. No meaningful index patch is possible.

### 9.2 Codebook storage and reuse

The codebook is stored in the INDEX section (0x04). On every build after the first:

1. Engine loads codebook from `.vpack-cache/previous.vpack` (INDEX section partial read)
2. Uses this codebook for all cluster assignments — does not retrain
3. Serializes the same codebook into the new artifact's INDEX section

The codebook is byte-identical between consecutive versions (absent a parameter change).

### 9.3 When retraining occurs

- First build (no previous artifact)
- `nlist`, `m`, or `bits` changes in the manifest
- Operator explicitly requests: `vpack build --retrain-codebook`

On retraining, the producer sets `flags.codebook_changed = true`. All subscribed consumers perform catch-up for this version transition. After catch-up, the new codebook is in effect and patch updates resume normally.

### 9.4 Detecting codebook drift

Over time, as corpus content shifts, the original codebook centroids may no longer well-represent the vector space. Signs: high cluster size variance, declining query recall.

`vpack inspect` emits a warning when cluster size standard deviation exceeds 2× the mean. This is the recommended retraining trigger. Retraining is a deliberate, one-time catch-up cost traded for better ongoing patch efficiency and query recall.

---

## 10. Registry Protocol Extensions

These endpoints extend RFC-0001 §11.

### 10.1 Patch publication

```
POST /v1/packs/{scope}/{name}/patches
Authorization: Bearer {token}
Content-Type: application/vpack-patch
Body: binary .vpack.patch file

Response 201:
{
  "patch_hash": "sha256:abc...",
  "base_version": "3.13.0",
  "result_version": "3.14.0",
  "size_bytes": 524288,
  "has_index_patch": true,
  "has_changelog_entry": true,
  "published_at": "2026-02-27T06:00:00Z"
}

Response 422:
{ "error": "base_version_not_published",
  "message": "Base version 3.13.0 has not been published to this registry." }
```

The registry validates that `base_artifact_hash` matches the stored base artifact before accepting. Handled automatically by `@vpack/output-registry` with `publish_patch: true`.

### 10.2 Patch discovery

```
GET /v1/packs/{scope}/{name}/patches?since={version}

Response 200:
{
  "patches": [
    { "from_version": "3.12.0", "to_version": "3.13.0",
      "patch_hash": "sha256:def...", "size_bytes": 412000,
      "has_index_patch": true, "has_changelog_entry": true },
    { "from_version": "3.13.0", "to_version": "3.14.0",
      "patch_hash": "sha256:abc...", "size_bytes": 524288,
      "has_index_patch": true, "has_changelog_entry": true }
  ],
  "latest_version": "3.14.0",
  "catch_up_recommended": false,
  "patch_chain_intact": true
}
```

`catch_up_recommended: true` when: patch count exceeds `max_patch_chain` threshold (default 30), any patch has `codebook_changed: true`, or any patch is missing from the chain.

### 10.3 Patch download

```
GET /v1/packs/{scope}/{name}/patches/{from_version}/{to_version}

Response 200: binary .vpack.patch
Content-Type: application/vpack-patch
ETag: "sha256:abc..."    (patch hash — patches are immutable)
```

### 10.4 Webhook notification

```
POST {consumer_webhook_url}
X-VPack-Signature: sha256={hmac_sha256(body, webhook_secret)}
Content-Type: application/json
Body:
{
  "event": "patch_available",
  "pack": "@acme/knowledge",
  "from_version": "3.13.0",
  "to_version": "3.14.0",
  "patch_url": "https://registry.vpack.dev/v1/packs/@acme/knowledge/patches/3.13.0/3.14.0",
  "patch_hash": "sha256:abc...",
  "size_bytes": 524288
}
```

---

## 11. The Subscribe Primitive

`vpack subscribe` registers a consumer to receive updates. On first subscription it downloads the full artifact. On subsequent `vpack update` calls it applies available patches.

### 11.1 Subscription state (`~/.vpackrc`)

```yaml
subscriptions:
  "@acme/knowledge":
    local_path: "~/.vpack/packs/@acme/knowledge.vpack"
    current_version: "3.14.0"
    current_hash: "sha256:xyz..."
    subscribed_at: "2026-02-27T00:00:00Z"
    registry: "https://registry.vpack.dev"
    index_type: "ivf-pq"
    auto_update: false
```

### 11.2 Subscribe command

```bash
vpack subscribe @acme/knowledge
vpack subscribe @acme/knowledge@3.14.0      # pin to version
vpack subscribe @acme/knowledge --auto-update
vpack subscribe @acme/knowledge --registry https://registry.mycompany.com
```

On first subscription: download full artifact, verify hash, store to `local_path`, record state in `~/.vpackrc`.

### 11.3 Pack access after subscribe

```typescript
import { load } from '@vpack/client'
const index = await load('@acme/knowledge')  // uses local subscribed copy from ~/.vpackrc
const results = await index.query("what is our pricing strategy?")
```

---

## 12. The Update Primitive

```bash
vpack update @acme/knowledge          # one pack
vpack update                          # all subscribed packs
vpack update @acme/knowledge --dry-run
vpack update @acme/knowledge --catch-up
```

### 12.1 Update algorithm

```
1. GET /v1/packs/@acme/knowledge/patches?since={current_version}

2. IF catch_up_recommended OR --catch-up flag:
   GOTO §13

3. IF patches is empty:
   PRINT "Already up to date at {current_version}."
   EXIT

4. FOR EACH patch in patches (in from_version order):
   a. Download patch file
   b. Verify patch.base_artifact_hash == sha256(local_artifact)
      IF mismatch: EMIT warning, GOTO §13
   c. Apply patch using §7
   d. IF application fails: GOTO §13

5. PRINT "Updated {start_version} → {latest_version}. {n} patches applied."
```

### 12.2 Dry run output

```
$ vpack update @acme/knowledge --dry-run

Pack:     @acme/knowledge
Current:  3.12.0 (2 patches behind)
Latest:   3.14.0

Patches available:
  3.12.0 → 3.13.0   412 KB   (2026-02-26)
  3.13.0 → 3.14.0   524 KB   (2026-02-27)

Total download:  936 KB
Full artifact:  52.3 MB   (patches are 1.8% of full size)

Run without --dry-run to apply.
```

---

## 13. Catch-Up

When sequential patch application is not practical, the consumer downloads the full artifact.

### 13.1 When catch-up is triggered

- `catch_up_recommended: true` in discovery response
- `flags.codebook_changed = true` in any patch in the chain
- `patch_chain_intact: false`
- Any patch application failure
- `vpack update --catch-up` flag

### 13.2 Catch-up procedure

```
1. GET /v1/packs/@acme/knowledge/{latest_version}/bundle
2. Verify sha256(downloaded_bytes) matches registry-declared hash
3. Write to temp file, rename(temp, local_path)   (atomic)
4. Update ~/.vpackrc: current_version, current_hash
```

### 13.3 Catch-up and temporal history

For temporal packs (RFC-0004), the full artifact already contains the complete CHANGELOG section with all history up to the latest version. Catch-up does not lose temporal history — it is present in the artifact as published.

---

## 14. Interaction with Temporal Knowledge (RFC-0004)

**Producer side:** When `@vpack/output-diff-summary` runs in the same build as `@vpack/output-registry` with `publish_patch: true`, it writes a pre-embedded `ChangelogChunk` to `.vpack-cache/next-changelog.json`. The patch producer (§6 step 7) reads this and includes it as CHANGELOG ENTRY (0x03). The entry is pre-embedded by the producer — the consumer requires no LLM API key.

**Consumer side:** On patch application (§7 step 6), if CHANGELOG ENTRY is present and RFC-0004 is implemented, the `ChangelogChunk` is appended directly to the CHANGELOG section (0x06) of the staged artifact. The consumer accumulates history without running any build pipeline.

**Completeness:** Every patch carries its own CHANGELOG ENTRY. A consumer who applies every patch accumulates every changelog entry in order. A consumer who catches up receives all history in the full artifact's CHANGELOG section. Both paths produce complete temporal history.

---

## 15. CLI Reference

```bash
# Subscription management
vpack subscribe @acme/knowledge [--registry URL] [--auto-update] [--version X.Y.Z]
vpack unsubscribe @acme/knowledge [--keep-artifact]
vpack subscriptions                                   # list all subscriptions and status

# Updates
vpack update [@acme/knowledge]                        # one pack or all
vpack update @acme/knowledge --dry-run
vpack update @acme/knowledge --catch-up

# Patch inspection
vpack patch inspect ./change.vpack.patch              # show header, stats, diff summary
vpack patch verify ./change.vpack.patch               # verify hashes without applying
vpack patch apply ./change.vpack.patch --to pack.vpack  # manual application

# Pack diff
vpack diff @acme/knowledge:3.13.0 @acme/knowledge:3.14.0 --output ./diff.vpack.patch
```

---

## 16. Security Considerations

### 16.1 Verification is mandatory

Consumers MUST verify `base_artifact_hash` before applying any patch, and `result_artifact_hash` after. The CLI enforces both. SDK consumers that bypass these checks accept undetectable corruption risk.

### 16.2 PII in CHUNK DIFF

The CHUNK DIFF section includes `before_text` on modified chunks — the text of the previous chunk version. If source documents contain PII and `@vpack/transformer-pii` was not applied before chunking, `before_text` exposes that PII to patch consumers and to the registry.

Operators with PII-sensitive sources MUST apply `@vpack/transformer-pii` before the chunker. Unlike published full artifacts (immutable), patches can be deleted from the registry if PII exposure is discovered post-publication.

### 16.3 Codebook hash as a tamper signal

The `codebook_hash` in INDEX PATCH is verified before any cluster replacement. A malicious patch cannot silently corrupt the index by substituting incorrect cluster lists, because the consumer verifies that its codebook matches the producer's before accepting any cluster update.

### 16.4 Patch chain integrity

The registry tracks the full patch chain. The consumer can verify that each patch's `base_artifact_hash` matches the previous patch's `result_artifact_hash`, creating a verifiable chain of custody from initial build to current version.

### 16.5 Webhook authentication

Webhook notifications (§10.4) MUST be verified using `X-VPack-Signature` before acting on them. Consumers that accept unauthenticated webhook notifications risk applying patches triggered by a third party.

---

## 17. Backward Compatibility

### 17.1 Packs using Det-HNSW

Packs built with `index.type: hnsw` continue to work unchanged for all non-patch operations. `vpack subscribe` is available but updates via catch-up only (no INDEX PATCH). Setting `publish_patch: true` with `index.type: hnsw` emits a hard manifest validation error.

### 17.2 Migration from HNSW to IVF-PQ

```yaml
# Before
index:
  type: hnsw

# After
index:
  type: ivf-pq
  nlist: 4096
  nprobe: 32
  m: 96
  bits: 8
  rerank: 256
```

The first build after migration rebuilds the INDEX with a new codebook. The produced patch carries `flags.codebook_changed = true`. All subscribers receive a catch-up signal and download the full artifact. After that, patch-based updates proceed normally.

---

## 18. Open Questions

**Q1: Multi-pack patch composability.** A consumer subscribed to `@acme/engineering` and `@acme/product` has two separate patch chains. Should there be a way to maintain a merged artifact that stays current via both? Related to RFC-0001 Q1 and Q5.

**Q2: Partial subscription.** Can a consumer subscribe to only specific sections — e.g., CHUNKS + VECTORS but not INDEX — and maintain their own index locally? Useful for consumers with specialized index requirements.

**Q3: Producer signature.** Should patches carry a cryptographic signature from the pack owner, allowing consumers to verify that a patch was produced by the same entity as the original artifact?

**Q4: `max_patch_chain` policy.** The default threshold of 30 patches for catch-up recommendation is a guess. For a daily-rebuilding pack, 30 patches is 30 days — reasonable. For an hourly pack, 30 patches is 30 hours. Should the threshold be time-based rather than count-based?

**Q5: Codebook retraining trigger.** §9.4 recommends retraining when cluster size standard deviation exceeds 2× the mean. Should `vpack inspect` emit this warning automatically and suggest `vpack build --retrain-codebook`?

**Q6: Write conflicts on concurrent update.** If two processes apply a patch to the same artifact simultaneously, the atomic rename at step 10 of §7 ensures one wins. The loser's staging work is wasted. Should the consumer lock the artifact file during patch application?

---

*This RFC is a living document. Discussion and amendments welcome via GitHub Issues and Pull Requests.*

*VectorPack is an open specification. Implementations are not required to be affiliated with the core project.*