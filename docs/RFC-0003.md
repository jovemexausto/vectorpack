# RFC-0003: Deterministic IVF-PQ for Reproducible VectorPack Indexes

**Status:** Draft  
**Version:** 0.1.0  
**Created:** 2026-02-26  
**Updated:** 2026-02-26  
**Authors:** VectorPack Contributors  

### Changelog

- **0.1.0** — Initial draft.

---

## Abstract

This document proposes an extension to VectorPack (RFC-0001) by introducing a deterministic variant of the Inverted File with Product Quantization (IVF-PQ) index as an alternative or complement to HNSW for the INDEX section (§3.1 of RFC-0001). IVF-PQ is inherently easier to make fully deterministic than graph-based methods like HNSW, addressing the reproducibility guarantee (§4.3 of RFC-0001) with lower complexity, better memory efficiency, and scalability for large packs.

Det-IVF-PQ eliminates non-determinism in clustering and quantization while preserving high recall and fast queries. This is an optional engine feature, configurable via BuildOptions, but recommended for verified packs where memory constraints or build speed are priorities. It builds on RFC-0002 (Det-HNSW) as a parallel path, allowing packs to choose the best index type.

---

## Table of Contents

1. [Motivation](#1-motivation)
2. [Terminology](#2-terminology)
3. [Non-Determinism in Standard IVF-PQ](#3-non-determinism-in-standard-ivf-pq)
4. [Det-IVF-PQ Algorithm](#4-det-ivf-pq-algorithm)
5. [Engine Integration](#5-engine-integration)
6. [Manifest and BuildOptions Extension](#6-manifest-and-buildoptions-extension)
7. [Serialization and Bundle Impact](#7-serialization-and-bundle-impact)
8. [Performance Considerations](#8-performance-considerations)
9. [Reproducibility Verification](#9-reproducibility-verification)
10. [Security Considerations](#10-security-considerations)
11. [Open Questions](#11-open-questions)

---

## 1. Motivation

RFC-0001 requires byte-identical artifacts for reproducibility, but standard HNSW introduces variability (addressed in RFC-0002 via Det-HNSW). IVF-PQ offers a compelling alternative: it is list-based (easier deltas), compressed (lower memory/disk), and faster to build at scale, while being simpler to determinize.

This extension enables Det-IVF-PQ for packs where:

- **Memory efficiency** is key (e.g., billion-chunk enterprise packs).
- **Build speed** matters (k-means vs. graph insertion).
- **Delta-sync** is prioritized (appends to clusters are cheap).
- **Recall trade-offs** are acceptable (tunable via parameters).

Det-IVF-PQ ensures the same inputs yield identical indexes, closing the reproducibility gap with less overhead than Det-HNSW modifications.

---

## 2. Terminology

| Term | Definition |
|---|---|
| **Det-IVF-PQ** | Deterministic Inverted File with Product Quantization — the variant specified here. |
| **nlist** | Number of coarse clusters/centroids in IVF. |
| **nprobe** | Number of clusters probed during query. |
| **m** | Number of subspaces in PQ (controls compression). |
| **bits** | Bits per PQ code (usually 8 for 256 centroids per subspace). |
| **Codebook** | Set of centroids for IVF or PQ subspaces. |
| **Inverted List** | Per-cluster list of vector IDs and PQ codes. |
| **Global Seed** | Fixed value from manifest hash for hash-based pseudo-randomness. |
| **Rerank** | Optional exact distance recompute on top candidates. |

Terms from RFC-0001 and RFC-0002 apply.

---

## 3. Non-Determinism in Standard IVF-PQ

Standard IVF-PQ (ScaNN/Faiss style) has limited variability:

1. **k-means Initialization**: Random centroid starting points or data subsampling.
2. **Training Order**: Vector order affects codebook convergence.
3. **Tie-Breaking**: Equal distances in cluster assignment.
4. **Floating-Point Instability**: Minor across platforms.

These are easier to fix than HNSW's graph heuristics.

---

## 4. Det-IVF-PQ Algorithm

Det-IVF-PQ follows standard IVF-PQ but uses fixed seeds, sorted processing, and stable tie-breakers. Parameters (nlist, nprobe, m, bits) are configurable.

### 4.1 Deterministic k-means for Codebooks

- Sort vectors by chunk ID before training.
- Initialize centroids: Use fixed-seed k-means++ (hash-based selection).
- Converge deterministically: Fixed iterations or tolerance; stable assignments via `(dist, node_id_hash)` sort.

### 4.2 Deterministic Vector Assignment

- For IVF: Assign to nearest centroid; ties by lowest `(hash(centroid_id + global_seed), centroid_id)`.
- For PQ: Split vector into m subspaces; assign each to nearest sub-centroid (same tie-breaker).

### 4.3 Inverted Lists Construction

- Sort lists by chunk ID asc.
- Store PQ codes + node IDs.

### 4.4 Query Process

- Coarse: Find nprobe nearest centroids to query (deterministic ties).
- Fine: Scan probed lists, compute approx dist via PQ lookups.
- Rerank: Optional exact dist on top-k candidates (sorted by approx dist + ties).

### 4.5 Global Seed

- Same as RFC-0002: `u64_from_sha256(manifest_hash)`.

---

## 5. Engine Integration

Implement in Rust engine (§9 of RFC-0001). Fallback to Det-HNSW if not selected.

### 5.1 Build Method Extension

```rust
impl VPackEngine {
    fn build(chunks: Vec<EmbeddedChunk>, options: BuildOptions) -> Result<VPackIndex, VPackError> {
        if options.index_type != "ivf-pq" { return det_hnsw_build(chunks, options); }

        let global_seed = derive_seed(&options.manifest_hash);
        let mut sorted_chunks = chunks;
        sorted_chunks.sort_by_key(|c| c.chunk.id.as_bytes());

        let vectors: Vec<&[f32]> = sorted_chunks.iter().map(|c| &c.vector).collect();

        // Train IVF centroids
        let ivf_codebook = deterministic_kmeans(&vectors, options.nlist, global_seed, options.kmeans_iters);

        // Assign to clusters
        let mut inverted_lists: Vec<Vec<(u64, Vec<u8>)>> = vec![vec![]; options.nlist];
        for chunk in &sorted_chunks {
            let node_id = derive_node_id(&chunk.chunk.id);
            let cluster_id = deterministic_assign(&chunk.vector, &ivf_codebook, global_seed);
            let pq_code = compute_pq_code(&chunk.vector, &pq_codebooks, options.m, options.bits); // similar deterministic train/assign
            inverted_lists[cluster_id].push((node_id, pq_code));
        }

        // Sort each list
        for list in &mut inverted_lists {
            list.sort_by_key(|(id, _)| *id);
        }

        Ok(VPackIndex { ivf_pq: DetIVFPQ { codebooks: ..., lists: inverted_lists, ... } })
    }
}
```

Query: Standard IVF-PQ scan + PQ dist + optional rerank.

### 5.2 Backward Compatibility

- Phase 1 (JS): Emulate with numeric.js or similar.
- Old packs: Rebuild with flag; detect via bundle flags.

---

## 6. Manifest and BuildOptions Extension

Add optional manifest field:

```yaml
index:
  type: ivf-pq  # default: hnsw
  nlist: 4096
  nprobe: 32
  m: 96
  bits: 8
  rerank: 256  # top candidates for exact dist
```

Flows to BuildOptions in engine.

---

## 7. Serialization and Bundle Impact

- INDEX (0x04): Serialize codebooks first (sorted), then lists (by cluster ID, internal sort).
- Smaller than HNSW (compressed codes).
- Bundle header: Add flag bit for index_type.

---

## 8. Performance Considerations

| Metric | Det-HNSW | Det-IVF-PQ | Notes |
|--------|----------|------------|-------|
| Build Time | O(N log N) | O(N * nlist / subsamples) | IVF-PQ faster at scale. |
| Query Latency | O(log N) | O(nprobe * list_size / N) | IVF-PQ higher throughput. |
| Recall@10 | 0.92–0.98 | 0.85–0.95 (tunable) | IVF-PQ lower; use rerank. |
| Memory | O(N * M) | O(N * m / 8) + codebooks | IVF-PQ much lower. |

Benchmarks on text embeddings required.

---

## 9. Reproducibility Verification

- Same as RFC-0002: `vpack verify --reproducible`.
- Engine throws if non-deterministic detected.

---

## 10. Security Considerations

- Compression loss: No new risks; recall impact documented.
- Aligns with RFC-0001 (§15).

---

## 11. Open Questions

**Q1: Default index?** Switch to Det-IVF-PQ for large packs?

**Q2: Hybrid?** IVF as coarse + HNSW refine?

**Q3: GPU support?** For training in Rust engine?

**Q4: Delta-sync?** IVF-PQ appends easier; spec extension?

---

*This RFC is a living document. Discussion and amendments welcome via GitHub Issues and Pull Requests.*

*VectorPack is an open specification. Implementations are not required to be affiliated with the core project.*