# RFC-0002: Deterministic HNSW for Reproducible VectorPack Indexes

**Status:** Draft  
**Version:** 0.1.0  
**Created:** 2026-02-26  
**Updated:** 2026-02-26  
**Authors:** VectorPack Contributors  

### Changelog

- **0.1.0** — Initial draft.

---

## Abstract

This document specifies a deterministic variant of the Hierarchical Navigable Small World (HNSW) graph for use in VectorPack artifacts. The standard HNSW algorithm introduces non-determinism through random level assignment, insertion order sensitivity, and heuristic neighbor selection, which prevents byte-identical reproducibility of VectorPack bundles (§4.3 of RFC-0001). Det-HNSW eliminates these sources of variability while preserving HNSW's high recall and query performance, enabling the full reproducibility guarantee: identical manifest + sources + plugins + content → byte-identical artifact, including the INDEX section.

Det-HNSW is an internal extension to the VectorPack engine (§9 of RFC-0001) and requires no changes to the manifest schema or plugin interfaces. It is mandatory for verified packs on the public registry to ensure query-on-registry consistency.

---

## Table of Contents

1. [Motivation](#1-motivation)
2. [Terminology](#2-terminology)
3. [Non-Determinism in Standard HNSW](#3-non-determinism-in-standard-hnsw)
4. [Det-HNSW Algorithm](#4-det-hnsw-algorithm)
5. [Engine Integration](#5-engine-integration)
6. [Serialization and Bundle Impact](#6-serialization-and-bundle-impact)
7. [Performance Considerations](#7-performance-considerations)
8. [Reproducibility Verification](#8-reproducibility-verification)
9. [Security Considerations](#9-security-considerations)
10. [Open Questions](#10-open-questions)

---

## 1. Motivation

RFC-0001 (§4.3) states: "Given the same manifest, the same source content, and the same plugin versions, `vpack build` must produce a byte-identical artifact." This is critical for VectorPack's goals of portability, verifiability, and delta-sync efficiency. However, the INDEX section (§3.1, 0x04) — a serialized HNSW graph — is non-deterministic in standard implementations, violating this guarantee.

Det-HNSW resolves this by making graph construction fully deterministic without sacrificing core HNSW benefits (high recall, low query latency). This enables:

- **Byte-identical bundles** across independent builds and machines.
- **Consistent query-on-registry** results for verified packs.
- **Easier delta-sync** extensions (e.g., compact INDEX deltas for incremental updates).
- **Reproducible testing** and benchmarking in VectorPack development.

Without this, the reproducibility claim in RFC-0001 is incomplete, as INDEX variability can lead to divergent query results even with identical vectors.

---

## 2. Terminology

| Term | Definition |
|---|---|
| **Det-HNSW** | Deterministic Hierarchical Navigable Small World graph — the variant specified here. |
| **Level Assignment** | Process of determining a node's maximum layer in the hierarchy. |
| **Neighbor Selection** | Heuristic for choosing M nearest neighbors during insertion. |
| **Entry Point** | Starting node for greedy descent in search/insert. |
| **Global Seed** | A fixed value derived from the manifest hash, used for hash-based pseudo-randomness. |
| **Chunk ID** | Deterministic sha256 hash from RFC-0001 (§3.2). |
| **Node ID** | Internal u64 derived from chunk ID hash for graph nodes. |

Terms from RFC-0001 (e.g., Pack, Manifest, Chunk, Engine) apply here.

---

## 3. Non-Determinism in Standard HNSW

Standard HNSW (Malkov & Yashunin, 2016–2018) has these variability sources:

1. **Random Level Assignment**: Exponential distribution via RNG (`floor(-ln(uniform(0,1)) * ln(M))`).
2. **Insertion Order Sensitivity**: Graph structure depends on addPoint order; different orders yield different connectivity.
3. **Heuristic Neighbor Selection**: Candidate sorting can be unstable (ties in distance, no fixed tie-breaker).
4. **Entry Point Variability**: Often the last inserted or a random high-level node.
5. **Floating-Point Instability**: Minor across machines/compilers, but can affect distance ties.

These make identical inputs produce different graphs, hence different serialized INDEX sections.

---

## 4. Det-HNSW Algorithm

Det-HNSW follows the standard HNSW pseudocode but replaces non-deterministic steps with hash-based or sorted alternatives. Parameters (M, ef_construction, max_level) remain configurable via BuildOptions (§9.1 of RFC-0001).

### 4.1 Deterministic Level Assignment

- Use a hash of the vector bytes to simulate the exponential distribution deterministically.
- Formula:  
  Let `h = hash(vector_bytes + global_seed)` (e.g., using ahash or SHA-256).  
  Let `prob = (h / MAX_HASH) ^ (1 / M)`.  
  Level = `floor(abs(ln(prob)))`.min(max_level).  
- This ensures the same vector always gets the same level, mimicking the probabilistic distribution.

### 4.2 Fixed Insertion Order

- Always sort EmbeddedChunks by chunk ID (lexicographical byte order) before insertion.  
- `sorted_chunks = chunks.sorted_by_key(|c| c.chunk.id.as_bytes())`  
- Insert in this order for every build.

### 4.3 Deterministic Neighbor Selection

- For a candidate set C = [(node_id, dist)], sort by:  
  1. Ascending dist (f32).  
  2. Ascending hash(node_id + global_seed).  
  3. Ascending node_id.  
- Take top ef_construction from sorted list.  
- Preserves diversity heuristic intent but eliminates ties/unstability.

### 4.4 Deterministic Entry Point

- Global entry point = node with highest level; ties broken by lowest node_id.  
- If no nodes yet, use a fixed dummy (removed post-build).

### 4.5 Distance and Graph Construction

- Use standard cosine/Euclidean (per embedder).  
- Node IDs = stable u64 hash of chunk ID.  
- During insert: greedy descent from deterministic entry point.

### 4.6 Global Seed Derivation

- `global_seed = u64_from_sha256(manifest_hash)` (from bundle header, §3.1).  
- Ensures seed is fixed per manifest.

---

## 5. Engine Integration

Det-HNSW is implemented in the Rust engine (§9 of RFC-0001). No changes to TypeScript interfaces or adapters.

### 5.1 Build Method Extension

```rust
impl VPackEngine {
    fn build(chunks: Vec<EmbeddedChunk>, options: BuildOptions) -> Result<VPackIndex, VPackError> {
        let global_seed = derive_seed(&options.manifest_hash);
        let mut sorted_chunks = chunks;
        sorted_chunks.sort_by_key(|c| c.chunk.id.as_bytes());

        let mut graph = DetHNSW::new(options.m, options.ef_construction, options.dimensions, global_seed);

        for chunk in sorted_chunks {
            let vector = &chunk.vector;
            let node_id = derive_node_id(&chunk.chunk.id);

            let level = deterministic_level(vector, global_seed, options.max_level);
            let entry_point = graph.deterministic_entry_point();
            let candidates = graph.greedy_search(vector, entry_point, options.ef_construction);
            let neighbors = deterministic_select_neighbors(&candidates, options.m, global_seed);

            graph.add_node(node_id, vector, level, neighbors);
        }

        Ok(VPackIndex { graph, /* other structures */ })
    }
}
```

Query remains standard HNSW greedy descent.

### 5.2 Backward Compatibility

- Phase 1 (TypeScript engine): Emulate Det-HNSW logic in JS (using crypto.subtle for hashes).
- Phase 2 (Rust): Native implementation.
- Existing packs: Rebuild with Det-HNSW for reproducibility; old packs flagged as "non-deterministic" in `vpack inspect`.

---

## 6. Serialization and Bundle Impact

- INDEX section (§3.1, 0x04): Serialize graph in canonical order (nodes by ID asc, links by target ID asc).  
- Use bincode with fixed endianness.  
- No size increase; structure identical to standard HNSW.  
- Bundle header unchanged.

---

## 7. Performance Considerations

| Metric | Standard HNSW | Det-HNSW | Notes |
|--------|---------------|----------|-------|
| Build Time | O(N log N) | Similar (+O(N log N) sort) | Negligible overhead. |
| Query Latency | O(log N) | Identical | No change. |
| Recall@10 | 0.95–0.99 | 0.92–0.98 | Minor drop possible; tune ef_construction +10–20%. |
| Memory | O(N * M) | Identical | No change. |

Benchmarks required pre-0.2.0: Test on 10k–1M chunk datasets (text/code embeddings).

---

## 8. Reproducibility Verification

- CLI: `vpack verify --reproducible @acme/product-vision:2.1.0` rebuilds locally and compares bundle hash.  
- Registry: Enforce for verified packs; reject non-Det-HNSW uploads.  
- Error: `VPackError::NonDeterministicIndex` if detected.

---

## 9. Security Considerations

- Hash-based determinism: Relies on collision-resistant hashes (SHA-256/ahash); no new vectors.  
- No impact on PII/model pinning from RFC-0001 (§15).  
- Reproducible graphs prevent silent divergence in distributed queries.

---

## 10. Open Questions

**Q1: Recall tuning.** If deterministic choices reduce recall on some datasets, add optional "diversity seed" (still fixed per manifest)?

**Q2: Delta extensions.** Det-HNSW enables deterministic deltas (RFC extension); prioritize?

**Q3: Alternative indexes.** If Det-HNSW recall drops too much, consider IVF-PQ hybrids?

**Q4: JS emulation.** Acceptable precision loss in TypeScript (f64 vs. Rust f32)?

---

*This RFC is a living document. Discussion and amendments welcome via GitHub Issues and Pull Requests.*

*VectorPack is an open specification. Implementations are not required to be affiliated with the core project.*