# RFC-0001: VectorPack Format Specification

**Status:** Draft  
**Version:** 0.3.0  
**Created:** 2026-02-26  
**Updated:** 2026-02-26  
**Authors:** VectorPack Contributors  

### Changelog

- **0.3.0** — Unified plugin architecture introduced. Pipeline stages formalised: `source`, `transformer` (pre/post-chunk), `chunker` (required named boundary), `embedder`, `output`, `middleware`. Chunker promoted to required named stage — structurally distinct from transformers — with enforced pipeline validation. Shorthand manifest blocks removed in favor of unified `plugins:` list. §5–§8 replaced by §5 Plugin System and §6 The Build Pipeline. Official plugin catalogue added. Migration appendix added.
- **0.2.0** — Rust engine architecture specified; registry pack tiers introduced; open source model constraint for public packs resolved; registry-as-query-engine protocol formalised; output plugins added; Q4 closed.
- **0.1.0** — Initial draft.

---

## Abstract

This document specifies VectorPack — an open, portable format for packaging, versioning, and distributing knowledge artifacts. A VectorPack bundle (`.vpack`) contains embedded vector representations of a document corpus alongside the original text, metadata, and full provenance information, enabling any LLM tool or agent to query the knowledge without rebuilding the ingestion pipeline.

VectorPack is to knowledge what npm is to code and Docker is to environments: a standard artifact format that makes knowledge portable, reproducible, and composable.

---

## Table of Contents

1. [Motivation](#1-motivation)
2. [Terminology](#2-terminology)
3. [The Bundle Format](#3-the-bundle-format)
4. [The Manifest](#4-the-manifest)
5. [Plugin System](#5-plugin-system)
6. [The Build Pipeline](#6-the-build-pipeline)
7. [Official Plugin Catalogue](#7-official-plugin-catalogue)
8. [Embedding Models](#8-embedding-models)
9. [The Query Engine](#9-the-query-engine)
10. [The Query Interface](#10-the-query-interface)
11. [The Registry Protocol](#11-the-registry-protocol)
12. [Registry Pack Tiers](#12-registry-pack-tiers)
13. [Adapters](#13-adapters)
14. [Versioning and Content Addressing](#14-versioning-and-content-addressing)
15. [Security Considerations](#15-security-considerations)
16. [Open Questions](#16-open-questions)

---

## 1. Motivation

Building a RAG pipeline today means reinventing the same ingestion stack over and over: choose a chunking strategy, call an embedding API, wire up a vector store, write retrieval logic, handle serialization. Every team solves this individually. Knowledge that took effort to curate — a company's decisions, a codebase's documentation, a domain expert's writing — is locked inside proprietary pipelines with no standard way to share or reuse it.

VectorPack addresses this by separating two concerns that are currently conflated:

**Knowledge compilation** — turning raw documents into a queryable index — happens once, offline, reproducibly.

**Knowledge consumption** — querying that index from any tool or language — happens everywhere, cheaply, without rebuilding anything.

The result is an artifact: a `.vpack` file. Like a compiled binary, it is self-contained and ready to run. Unlike a binary, it carries full provenance — you always know what went in, how it was processed, and when it was built.

---

## 2. Terminology

| Term | Definition |
|---|---|
| **Pack** | A compiled `.vpack` artifact containing chunks, vectors, and metadata |
| **Manifest** | The `vpack.yml` file describing how a pack is built |
| **Chunk** | A unit of text with its vector, ID, and metadata |
| **Plugin** | An npm package that participates in the build pipeline at a declared stage |
| **Source** | A plugin (`kind: source`) that fetches raw documents for ingestion |
| **Transformer** | A plugin (`kind: transformer`) that modifies documents or chunks in the stream |
| **Chunker** | A plugin (`kind: chunker`) that splits raw documents into chunks — the required pipeline boundary |
| **Embedder** | A plugin (`kind: embedder`) that produces embedding vectors from chunk text |
| **Output** | A plugin (`kind: output`) that consumes the finished index and pushes it somewhere |
| **Middleware** | A plugin (`kind: middleware`) that wraps the entire build pipeline |
| **Registry** | A content-addressed server for publishing and pulling packs |
| **Verified pack** | A public pack built with an approved open source embedding model |
| **Hosted pack** | A public pack built with any model; query-on-registry not available |
| **Adapter** | A language-specific library for querying a pack |
| **Engine** | The Rust core that performs HNSW indexing, vector math, and serialization |
| **Fingerprint** | A deterministic hash of source content used for change detection |
| **Query-on-registry** | Querying a pack server-side without downloading the artifact |
| **Build context** | Shared read-only state passed through the pipeline: manifest, changed chunk IDs, build ID |

---

## 3. The Bundle Format

A `.vpack` file is a binary archive using a defined columnar layout. It is **not** a zip file. The layout is designed for partial reads — consumers can seek into specific sections without loading the entire artifact.

### 3.1 File Layout

```
┌─────────────────────────────────┐
│  HEADER (fixed 64 bytes)        │
│  magic: b"VPACK"                │
│  spec_version: u8               │
│  flags: u16                     │
│  section_count: u8              │
│  manifest_hash: [u8; 32]        │
├─────────────────────────────────┤
│  SECTION TABLE                  │
│  [ section_id: u8               │
│    offset: u64                  │
│    length: u64                  │
│    checksum: u32 ] × N          │
├─────────────────────────────────┤
│  SECTION: MANIFEST (0x01)       │
│  UTF-8 encoded vpack.yml        │
├─────────────────────────────────┤
│  SECTION: CHUNKS (0x02)         │
│  bincode-encoded Vec<Chunk>     │
├─────────────────────────────────┤
│  SECTION: VECTORS (0x03)        │
│  raw f32 arrays, row-major      │
│  parallel to CHUNKS section     │
├─────────────────────────────────┤
│  SECTION: INDEX (0x04)          │
│  serialized HNSW graph          │
├─────────────────────────────────┤
│  SECTION: PROVENANCE (0x05)     │
│  source fingerprints + timestamps│
└─────────────────────────────────┘
```

Sections are independent. A consumer needing only metadata reads MANIFEST. A consumer performing remote query traversal reads INDEX and VECTORS without loading CHUNKS. This enables streaming query protocols over the registry.

**Implementation note (Rust engine):** The current Rust engine writes a simplified v0x02 format (magic `VPAK`, version `0x02`, length-prefixed bincode payload containing `manifest` and `chunks`). The legacy TypeScript v0x01 JSON payload format is no longer supported; existing `.vpack` files must be rebuilt.

### 3.2 The Chunk Schema

```typescript
interface Chunk {
  id: string                       // deterministic: sha256(source_id + offset)
  text: string                     // original text, preserved verbatim
  metadata: {
    source_plugin: string          // e.g. "@vpack/source-notion"
    source_id: string              // stable identifier within the source
    source_url?: string            // human-readable origin
    created_at?: string            // ISO 8601
    updated_at?: string            // ISO 8601
    pack_name: string              // which pack this chunk belongs to
    chunker_plugin: string         // e.g. "@vpack/chunker-semantic"
    [key: string]: unknown         // plugin-defined fields
  }
}
```

Chunk IDs are deterministic. The same document, processed with the same settings, always produces the same chunk IDs. This is required for delta sync. The `chunker_plugin` field records which chunker produced this chunk, enabling per-chunker attribution in mixed-strategy packs.

---

## 4. The Manifest

The manifest is a `vpack.yml` file at the root of a pack's source repository. It is the complete, reproducible description of how a pack is built.

### 4.1 Full Manifest Schema (Explicit Form)

The `plugins:` list is the canonical manifest form. Plugins are declared in pipeline order and executed in that order.

```yaml
# ── Identity ─────────────────────────────────────────────────────────
vpack: "1.0"                          # spec version (required)
name: "@acme/product-vision"          # scoped name, registry-unique (required)
version: "2.1.0"                      # semver (required)
description: "Acme product decisions and principles"
license: "CC-BY-4.0"                  # SPDX identifier
homepage: "https://github.com/acme/product-vision"

# ── Plugin pipeline ───────────────────────────────────────────────────
# Required: at least one source, exactly one chunker, exactly one embedder.
# Optional: transformers (pre/post-chunk), outputs, middleware.
# Validated before any source begins fetching.

plugins:
  # Sources — feed raw documents into the pipeline
  - kind: source
    use: "@vpack/source-fs"
    path: ./docs/
    include: ["**/*.md", "**/*.txt"]

  - kind: source
    use: "@vpack/source-notion"
    database_id: abc123
    filter: { property: Status, equals: Published }

  # Pre-chunk transformers — operate on RawDocument, run before chunking
  - kind: transformer
    use: "@vpack/transformer-markdown-clean"

  - kind: transformer
    use: "@vpack/transformer-translate"
    target_language: en
    only_if: "metadata.language != 'en'"

  - kind: transformer
    use: "@vpack/transformer-pii"
    redact: [email, phone, ssn]

  # Chunker — required, exactly once.
  # This is the type boundary: RawDocument stream becomes Chunk stream.
  # Plugins declared after this receive Chunk, not RawDocument.
  - kind: chunker
    use: "@vpack/chunker-semantic"
    size: 512
    overlap: 64
    min_size: 50

  # Post-chunk transformers — operate on Chunk, run after chunking
  - kind: transformer
    use: "@vpack/transformer-dedup"
    threshold: 0.98

  - kind: transformer
    use: "@vpack/transformer-extract"
    fields:
      - name: sentiment
        type: enum
        values: [positive, neutral, negative]

  # Embedder — required, exactly once.
  # For public registry packs, must be an approved open source model (see §12).
  - kind: embedder
    use: "@vpack/embedder-local"
    model: nomic-embed-text
    model_hash: sha256:abc123...
    dimensions: 768

  # Outputs — receive the finished VPackIndex after build
  - kind: output
    use: "@vpack/output-registry"
    ref: "@acme/product-vision:auto"

  - kind: output
    use: "@vpack/output-mcp"
    port: 3333

  - kind: output
    use: "@vpack/output-slack"
    channel: "#knowledge-updates"
```

### 4.2 Plugins‑Only Manifest

Manifests must declare the pipeline exclusively via `plugins:`. Top‑level shorthand
blocks (`sources`, `chunk`, `outputs`, `filters`, `embed`) are not supported in v0.3.0.

### 4.3 Reproducibility Guarantee

Given the same manifest, the same source content, and the same plugin versions, `vpack build` must produce a byte-identical artifact. The manifest hash embedded in the bundle header is a SHA-256 of the normalised manifest including all plugin declarations and their configs. Consumers can verify a pack was built from a given manifest without access to the source documents.

---

## 5. Plugin System

A plugin is an npm package that participates in the build pipeline at a declared stage. Each stage has a defined TypeScript interface. The pipeline assembles itself from whatever plugins are declared in the manifest — the core is a thin orchestrator, not a monolith with escape hatches.

### 5.1 Plugin Kinds and Pipeline Shape

```
[sources]                        kind: source
    ↓  RawDocument stream
[pre-chunk transformers]         kind: transformer  (before chunker)
    ↓  RawDocument stream
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
[chunker]       ◄── REQUIRED     kind: chunker
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
    ↓  Chunk stream              ← TYPE BOUNDARY: RawDocument → Chunk[]
[post-chunk transformers]        kind: transformer  (after chunker)
    ↓  Chunk stream
[embedder]      ◄── REQUIRED     kind: embedder
    ↓  EmbeddedChunk stream
[engine: build index]            (core — not a plugin)
    ↓  VPackIndex
[outputs]                        kind: output
[middleware]                     kind: middleware   (wraps entire pipeline)
```

The chunker is not a transformer. It is the **required type boundary** between the document world and the chunk world. Transformers are optional enrichment that preserve their item's type. The chunker is load-bearing infrastructure that changes the type. They are different things and must not be conflated.

The pipeline validator enforces this before any source begins fetching:

```
✗ No chunker declared — add a 'kind: chunker' plugin
✗ No embedder declared — add a 'kind: embedder' plugin
✗ No sources declared — at least one 'kind: source' plugin is required
✓ Pipeline valid — 2 sources, 2 pre-transformers, 1 chunker, 1 post-transformer, 1 embedder, 2 outputs
```

### 5.2 Source Interface (`kind: source`)

```typescript
export interface VPackSource<TConfig = unknown> {
  /**
   * Yield raw documents. Streaming — never load all into memory.
   */
  fetch(config: TConfig, ctx: BuildContext): AsyncIterable<RawDocument>

  /**
   * Return a stable hash of the current source state.
   * Identical fingerprint = skip re-fetch (delta build).
   */
  fingerprint(config: TConfig): Promise<string>

  describe(config: TConfig): SourceDescription
}

export interface RawDocument {
  id: string               // stable — must not change if content unchanged
  content: string
  metadata: Record<string, unknown>
  updated_at?: Date
}
```

### 5.3 Transformer Interface (`kind: transformer`)

```typescript
export interface VPackTransformer<TConfig = unknown> {
  /**
   * Pre-chunk: receives RawDocument, returns RawDocument | null.
   * Post-chunk: receives Chunk, returns Chunk | null.
   * Return null to drop the item from the pipeline entirely.
   *
   * Stage is inferred from declaration order relative to the chunker.
   * Override with an explicit `stage: pre-chunk | post-chunk` field in the manifest.
   */
  transform(
    item: RawDocument | Chunk,
    config: TConfig,
    ctx: BuildContext,
  ): Promise<RawDocument | Chunk | null>
}
```

### 5.4 Chunker Interface (`kind: chunker`)

```typescript
export interface VPackChunker<TConfig = unknown> {
  /**
   * Split a raw document into chunks.
   * Return an empty array to drop the document from the pipeline.
   * Must never return undefined — the pipeline contract requires an array.
   */
  chunk(doc: RawDocument, config: TConfig, ctx: BuildContext): Promise<Chunk[]>
}
```

Exactly one chunker must be declared per manifest. Zero or more than one is a validation error caught before any fetching begins.

### 5.5 Embedder Interface (`kind: embedder`)

```typescript
export interface VPackEmbedder<TConfig = unknown> {
  /** Embed a batch of texts. Returns one vector per input text. */
  embed(texts: string[], config: TConfig, ctx: BuildContext): Promise<number[][]>

  /** Dimensions of the produced vectors. All chunks in a pack share one vector space. */
  dimensions(config: TConfig): number

  /** Canonical model identifier, e.g. "nomic-embed-text". */
  modelId(config: TConfig): string

  /**
   * SHA-256 hash of model weights.
   * Build fails if this does not match the hash declared in the manifest.
   */
  modelHash(config: TConfig): Promise<string>
}
```

Exactly one embedder must be declared. Multiple embedders per pack are not supported — all chunks must share a vector space. For multi-model routing, use `@vpack/embedder-router`.

### 5.6 Output Interface (`kind: output`)

```typescript
export interface VPackOutput<TConfig = unknown> {
  /**
   * Receive the finished index after build.
   * ctx.changedChunkIds contains IDs of chunks that changed in this build.
   * Empty on first build — treat as full push.
   */
  push(index: VPackIndex, config: TConfig, ctx: BuildContext): Promise<void>

  describe(config: TConfig): OutputDescription
}
```

### 5.7 Middleware Interface (`kind: middleware`)

```typescript
export interface VPackMiddleware<TConfig = unknown> {
  wrap(pipeline: BuildPipeline, config: TConfig): BuildPipeline
}
```

Middleware wraps the entire pipeline. Most packs never need it. It is the extension point for cross-cutting concerns: caching, telemetry, dry-run mode, cost estimation.

### 5.8 Build Context

All plugin methods receive a `BuildContext`. Plugins can read it but not mutate it.

```typescript
export interface BuildContext {
  readonly manifest: PackManifest
  readonly previousBuildHash?: string    // hash of last successful build
  readonly changedChunkIds: Set<string>  // populated after chunking, before outputs
  readonly buildId: string              // unique per build run
  readonly dryRun: boolean              // true when --dry-run flag is set
}
```

### 5.9 Plugin Package Conventions

**Naming:** `@vpack/{kind}-{name}` for official plugins, `vpack-{kind}-{name}` for community plugins.

Examples: `@vpack/source-github`, `@vpack/chunker-semantic`, `vpack-source-confluence`, `vpack-transformer-redact`.

**Entry point:** every plugin exports a default export conforming to its kind's interface.

**Resolution:** plugins are loaded via dynamic import, resolved from the manifest directory using standard Node.js module resolution. Install them like any npm dependency.

---

## 6. The Build Pipeline

### 6.1 Execution Order

```
1.  Validate manifest and plugin graph — fail fast with clear errors
2.  Load all declared plugins
3.  Apply middleware wrapping (outermost middleware first)
4.  For each source (in declaration order):
      a. Call source.fingerprint() — skip if unchanged and cache valid
      b. Stream RawDocuments from source.fetch()
      c. Apply pre-chunk transformers in declaration order
5.  For each RawDocument passing through:
      a. Call chunker.chunk() → Chunk[]
      b. Apply post-chunk transformers in declaration order
6.  Batch all chunks and call embedder.embed()
7.  Build HNSW index from EmbeddedChunks
8.  Serialize to .vpack
9.  Run outputs in declaration order (BuildContext has changedChunkIds)
```

### 6.2 Fingerprint Caching

Before fetching from a source, `source.fingerprint()` is called. If the fingerprint matches the stored value from the last build, the source is skipped entirely and its previous chunks are reused. A nightly rebuild where only one of five sources changed runs only one source fetch.

Fingerprint cache lives in `.vpack-cache/fingerprints.json` alongside the manifest. Safe to commit — hashes only, no content.

### 6.3 Transformer Null Drops

When a transformer returns `null`, the item is dropped from the pipeline. No subsequent transformers see it. For documents dropped pre-chunk, no chunks are produced. This is how deduplication, PII filtering, and minimum-length enforcement work — as composable, ordered transformers, not monolithic filter lists.

### 6.4 Delta-Aware Outputs

After chunking, the pipeline computes `changedChunkIds`: the set of chunk IDs present in this build that differ from the previous build. Removed chunks are also tracked. All outputs receive this via `BuildContext`. Delta-aware outputs — like `@vpack/output-pg-vector` — use it to push only changed rows rather than reloading everything.

---

## 7. Official Plugin Catalogue

All official plugins are maintained in the VectorPack monorepo and published under the `@vpack` scope.

### 7.1 Sources

| Package | Fetches from |
|---|---|
| `@vpack/source-fs` | Local filesystem: `.md`, `.txt`, `.html`, `.pdf` |
| `@vpack/source-github` | Repo docs, resolved issues, merged PR descriptions |
| `@vpack/source-notion` | Pages and databases |
| `@vpack/source-slack` | Channel history and thread replies |
| `@vpack/source-linear` | Issues, comments, project docs |
| `@vpack/source-web` | Public URLs and sitemaps |
| `@vpack/source-confluence` | Spaces and pages |
| `@vpack/source-gdrive` | Google Drive documents and folders |

### 7.2 Transformers

| Package | What it does | Stage |
|---|---|---|
| `@vpack/transformer-markdown-clean` | Strip frontmatter, normalise headings, remove raw HTML | pre-chunk |
| `@vpack/transformer-pii` | Redact emails, phones, SSNs, credit card numbers | pre-chunk |
| `@vpack/transformer-translate` | Translate non-English docs to a target language | pre-chunk |
| `@vpack/transformer-summarize` | LLM-assisted summarization of long documents | pre-chunk |
| `@vpack/transformer-extract` | Attach structured metadata extracted from text content | pre or post |
| `@vpack/transformer-dedup` | Drop near-duplicate chunks by cosine similarity threshold | post-chunk |
| `@vpack/transformer-min-length` | Drop chunks below a minimum character count | post-chunk |
| `@vpack/transformer-normalize` | Whitespace normalisation and unicode cleanup | pre-chunk |

### 7.3 Chunkers

| Package | Strategy |
|---|---|
| `@vpack/chunker-fixed` | Fixed token window with configurable overlap |
| `@vpack/chunker-sentence` | Sentence-boundary aware, groups sentences to target size |
| `@vpack/chunker-paragraph` | Paragraph-boundary aware, preserves natural text units |
| `@vpack/chunker-semantic` | Embedding-based topic boundary detection |
| `@vpack/chunker-code` | AST-aware: splits by function, class, or module boundary |
| `@vpack/chunker-markdown` | Heading-aware: one chunk per section, respects hierarchy |
| `@vpack/chunker-legal` | Legal structure: splits by clause, section, article |

### 7.4 Embedders

| Package | Provider | Registry tier |
|---|---|---|
| `@vpack/embedder-xenova` | Local Xenova Transformers | verified |
| `@vpack/embedder-local` | Local open source models via fastembed | verified |
| `@vpack/embedder-openai` | OpenAI `text-embedding-3-*` | hosted only |
| `@vpack/embedder-voyage` | Voyage AI — strong for code and technical content | hosted only |
| `@vpack/embedder-cohere` | Cohere Embed v3 | hosted only |
| `@vpack/embedder-router` | Route chunks to different models by metadata, project to unified space | verified if all sub-models are open source |

### 7.5 Outputs

| Package | Destination |
|---|---|
| `@vpack/output-registry` | VectorPack registry (push as part of build) |
| `@vpack/output-mcp` | MCP resource endpoint |
| `@vpack/output-pg-vector` | Postgres pgvector (delta-aware upsert) |
| `@vpack/output-s3` | S3-compatible storage (raw `.vpack` artifact) |
| `@vpack/output-webhook` | HTTP POST on build complete with diff summary |
| `@vpack/output-slack` | Build summary and changed-chunk count to a channel |
| `@vpack/output-openai-files` | Upload to OpenAI Files API for Assistants |
| `@vpack/output-export-jsonl` | Dump chunks + vectors as JSONL for any vector DB |

### 7.6 Middleware

| Package | What it does |
|---|---|
| `@vpack/middleware-cache` | Fingerprint-based build cache (on by default) |
| `@vpack/middleware-telemetry` | OpenTelemetry spans per pipeline stage |
| `@vpack/middleware-dry-run` | Full pipeline run, skip serialization and outputs |
| `@vpack/middleware-cost` | Estimate embedding API cost before spending |
| `@vpack/middleware-rate-limit` | Throttle source fetches and embedding API calls |

---

## 8. Embedding Models

### 8.1 Model Mismatch is Silently Catastrophic

If a pack was built with model A and a query is embedded with model B, HNSW traversal completes normally and returns results with plausible scores — but those scores are geometrically meaningless. There is no runtime error. The results look valid and are completely wrong.

VectorPack prevents this at three levels:

**At build time** — the model identifier and hash are embedded in the bundle header. Any adapter loading the pack knows exactly which model produced the vectors.

**At query time (local)** — adapters perform a hard check: the model declared in the manifest must match the model used for query embedding. Mismatch throws `ModelMismatch`, never silently proceeds.

**At query time (registry)** — the registry embeds the query using the model declared in the pack manifest. The client sends plain text. Mismatch is architecturally impossible.

### 8.2 Approved Models for Verified Packs

| Model | Dimensions | Notes |
|---|---|---|
| `all-minilm-l6-v2` | 384 | Fast, good for short texts |
| `bge-small-en-v1.5` | 384 | Strong general retrieval |
| `bge-large-en-v1.5` | 1024 | Best quality in open source tier |
| `nomic-embed-text` | 768 | Long context, 8192 token window |
| `gte-small` | 384 | Efficient, multilingual-capable |

Private packs and self-hosted registries accept any model without restriction.

### 8.3 Model Pinning

The embedder plugin declares the model hash. Build fails if the locally available weights do not match:

```yaml
- kind: embedder
  use: "@vpack/embedder-local"
  model: nomic-embed-text
  model_hash: sha256:3e4b...
  dimensions: 768
```

---

## 9. The Query Engine

The query engine is the performance-critical core. It is implemented in Rust and shared across all language adapters and the registry server.

### 9.1 Engine Interface

```rust
pub trait VPackEngine {
    fn build(chunks: Vec<Chunk>, options: BuildOptions) -> Result<VPackIndex, VPackError>;
    fn query(index: &VPackIndex, input: QueryInput, options: QueryOptions) -> Result<Vec<QueryResult>, VPackError>;
    fn serialize(index: &VPackIndex) -> Result<Vec<u8>, VPackError>;
    fn deserialize(bytes: &[u8]) -> Result<VPackIndex, VPackError>;
}

pub enum QueryInput {
    Vector(Vec<f32>),   // pre-embedded — engine skips embedding step
    Text(String),       // engine embeds using model pinned in manifest
}
```

### 9.2 Typed Errors

```rust
pub enum VPackError {
    DimensionMismatch { expected: usize, got: usize },
    ModelMismatch { expected: String, got: String },  // hard error, never silent
    EmptyIndex,
    ModelHashMismatch { model: String, expected: String, got: String },
    Serialize(bincode::Error),
}
```

### 9.3 Compilation Targets

| Target | Used by | How |
|---|---|---|
| Native Node.js addon | TypeScript adapter, CLI | `napi-rs` |
| WebAssembly | Browser, edge runtimes | `wasm-bindgen` |
| Shared library | Python, Go, Ruby adapters | FFI via `cbindgen` |
| Standalone binary | Shell scripts, any process | Direct execution |

The TypeScript reference implementation ships first (Phase 1). The Rust implementation replaces it as Phase 2 with no interface changes.

---

## 10. The Query Interface

### 10.1 Core Operations

```typescript
const index = await engine.deserialize(bytes)         // from .vpack file
const index = await client.load('@acme/docs:latest')  // from registry

const results = await index.query("what is our pricing strategy?", {
  topK: 10,
  minScore: 0.7,
  filter: { field: "metadata.source_plugin", op: "eq", value: "@vpack/source-notion" },
  includeVectors: false,
})
// results: Array<{ chunk: Chunk, score: number, rank: number, vector?: number[] }>
```

### 10.2 Usage Examples

```typescript
// TypeScript — local file
import { engine } from '@vpack/engine'
import { readFileSync } from 'node:fs'
const index = engine.deserialize(new Uint8Array(readFileSync('./dist/pack.vpack')))
const results = await index.query([...preEmbeddedVector], { topK: 5 })

// TypeScript — registry
import { load } from '@vpack/client'
const index = await load('@community/react-docs:latest')
const results = await index.query("how does useEffect cleanup work?")

// Python
import vpack
index = vpack.load("@acme/product-vision:latest")
results = index.query("what do we believe about pricing?", top_k=10)

// Browser (WASM)
import { engine } from "@vpack/engine/wasm"
const bytes = await fetch("/my-pack.vpack").then(r => r.arrayBuffer())
const index = await engine.deserialize(new Uint8Array(bytes))
const results = await index.query("what is our pricing philosophy?", { topK: 5 })
```

---

## 11. The Registry Protocol

### 11.1 Endpoints

```
POST   /v1/auth/token
GET    /v1/packs/{scope}/{name}
GET    /v1/packs/{scope}/{name}/{version}
DELETE /v1/packs/{scope}/{name}/{version}
POST   /v1/packs/{scope}/{name}/{version}/upload/init
PUT    /v1/packs/{scope}/{name}/{version}/upload/{id}
POST   /v1/packs/{scope}/{name}/{version}/upload/complete
GET    /v1/packs/{scope}/{name}/{version}/bundle
GET    /v1/packs/{scope}/{name}/{version}/section/{id}
POST   /v1/packs/{scope}/{name}/{version}/query          # verified packs only
```

### 11.2 Chunked Upload

```typescript
POST /v1/packs/@acme/product-vision/2.1.0/upload/init
Body: { total_size: 104857600, section_hashes: { "0x02": "sha256:...", "0x03": "sha256:..." } }
Response: { upload_id: "ulp_abc123", missing_sections: ["0x03"] }
// missing_sections: only upload what the registry doesn't already have
```

### 11.3 Query-on-Registry

For `verified` packs, the registry embeds the query server-side:

```
POST /v1/packs/@community/react-docs/latest/query
Body: { "query": "how does useEffect cleanup work?", "top_k": 10, "min_score": 0.7 }
Response: { "results": [...], "model": "nomic-embed-text", "model_hash": "sha256:3e4b..." }
```

### 11.4 Self-Hosting

```yaml
services:
  registry:
    image: vpack/registry:latest
    environment:
      STORAGE_BACKEND: s3
      STORAGE_BUCKET: my-bucket
      DATABASE_URL: postgres://...
      EMBED_MODELS: "bge-small-en-v1.5,nomic-embed-text"
    ports: ["3000:3000"]
```

```yaml
# ~/.vpackrc
registry: https://registry.mycompany.com
```

---

## 12. Registry Pack Tiers

### 12.1 Verified Packs

Uses an approved open source embedder (§8.2). Supports query-on-registry. Eligible for `@community` scope. Reproducible by anyone without API keys.

### 12.2 Hosted Packs

Uses any embedder. Registry stores the artifact but cannot serve queries. Consumer must have access to the same model.

### 12.3 Tier Summary

| Property | Verified | Hosted |
|---|---|---|
| Allowed embedders | Approved open source | Any |
| Query-on-registry | ✓ | ✗ |
| Reproducible by anyone | ✓ | Depends on model access |
| Local query (with adapter) | ✓ | ✓ (model required) |
| Community scope eligible | ✓ | ✗ |
| Self-hosted registry | ✓ | ✓ |

---

## 13. Adapters

### 13.1 Official Adapters

| Package | Language | Distribution |
|---|---|---|
| `@vpack/client` | TypeScript / Node.js | npm |
| `vpack` | Python | PyPI |
| `vpack` | Rust | crates.io |
| `@vpack/client/wasm` | Browser / Edge | npm |

### 13.2 Framework Integrations

```typescript
import { VPackRetriever } from "@vpack/langchain"
const retriever = new VPackRetriever({ pack: "@acme/product-vision:latest" })

import { VPackMCPResource } from "@vpack/mcp"
server.addResource(new VPackMCPResource({ pack: "@acme/product-vision:latest" }))

import { vpackTool } from "@vpack/ai-sdk"
const tools = { knowledge: vpackTool("@acme/product-vision:latest") }
```

---

## 14. Versioning and Content Addressing

### 14.1 Pack Versioning

Semver. Registry enforces immutability — published versions cannot be overwritten, only yanked. Tags: `1.2.3` (exact), `latest`, `1.2` (latest patch).

### 14.2 Content Addressing

```
registry.vpack.dev/@acme/product-vision:2.1.0
  → manifest_hash: sha256:abc123...
    → section[VECTORS]: sha256:def456...
    → section[CHUNKS]: sha256:ghi789...
    → section[INDEX]: sha256:jkl012...
```

`vpack verify @acme/product-vision:2.1.0` walks this chain and confirms no tampering.

### 14.3 Delta Sync

Because chunk IDs are deterministic, a rebuild computes which IDs are new, modified, or removed. Only changed sections are re-uploaded.

---

## 15. Security Considerations

**Model pinning** prevents silent embedding drift. Build fails on model hash mismatch.

**Model mismatch is a hard error.** `ModelMismatch` halts — never proceeds silently. See §8.1.

**Manifest hash in bundle header** enables verification without source access.

**Content addressing** makes tampering detectable anywhere in the chain.

**Query-on-registry isolation** — registry uses locally hosted open source models. No query text leaves the operator's infrastructure.

**PII filtering** — `@vpack/transformer-pii` is available but not default. Operators are responsible for filtering before publishing.

**Plugin trust** — plugins run in the build process with full Node.js access. Only install plugins from trusted sources. Official `@vpack/*` plugins are published with provenance attestation.

**Private packs** — token-scoped registry access. The public registry hosts only publicly readable packs.

---

## 16. Open Questions

**Q1: Multi-pack queries.** Score normalisation across packs with different embedding models is non-trivial. How should merged results be ranked?

**Q2: Incremental index updates.** Full index rebuild on any source change. Is append-only HNSW update worth the complexity for large packs?

**Q3: Chunk-level access control.** Should chunks carry access control metadata for per-user result filtering within a single enterprise pack?

**Q4: Embedding model interoperability.** ~~Cross-model query?~~ **Closed.** Hard error. See §8.1.

**Q5: Pack composition at query time.** Runtime querying of two packs as one, without producing a merged artifact. Requires careful design for packs with different models.

**Q6: Plugin version pinning.** Should manifests pin plugin versions the way they pin model hashes? The reproducibility guarantee seems to require it, but the UX burden is high. A `vpack.lock` file generated automatically at build time is one option.

---

## Appendix A: CLI Reference

```bash
vpack build [--manifest vpack.yml] [--output my-pack.vpack] [--dry-run]
vpack query ./my-pack.vpack "what do we believe about pricing?"
vpack inspect ./my-pack.vpack [--section chunks] [--chunk <id>]
vpack validate [--manifest vpack.yml]
vpack login [registry]
vpack push ./my-pack.vpack @acme/product-vision:2.1.0
vpack pull @acme/product-vision:latest [--section vectors]
vpack verify @acme/product-vision:2.1.0
vpack merge pack-a.vpack pack-b.vpack --output merged.vpack
vpack diff @acme/product-vision:2.0.0 @acme/product-vision:2.1.0
```

---

## Appendix B: GitHub Actions Integration

```yaml
name: Build and Publish VectorPack
on:
  push:
    branches: [main]
  schedule:
    - cron: "0 6 * * *"

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: vpack/setup-action@v1
        with: { version: latest }
      - name: Build pack
        env:
          NOTION_TOKEN: ${{ secrets.NOTION_TOKEN }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: vpack build
        # Output plugins declared in vpack.yml run automatically.
        # vpack push is not a separate step — use kind: output + @vpack/output-registry.
```

---

## Appendix C: Self-Hosted Registry Quickstart

```bash
docker run -d \
  -e STORAGE_BACKEND=local -e STORAGE_PATH=/data \
  -e DATABASE_URL=sqlite:///data/registry.db \
  -v $(pwd)/data:/data -p 3000:3000 \
  vpack/registry:latest

echo "registry: http://localhost:3000" >> ~/.vpackrc
vpack push ./my-pack.vpack @me/my-knowledge:1.0.0
```

---

## Appendix D: Migration from v0.2.0

Manifests written for v0.2.0 must be migrated to v0.3.0. The shorthand blocks were removed; manifests now declare the pipeline exclusively via `plugins:` entries. The parser will reject deprecated top‑level fields, so update manifests before running `vpack build`.

```yaml
# v0.3.0 plugins-only manifest
plugins:
  - kind: source
    use: "@vpack/source-fs"
    path: ./docs
  - kind: transformer
    use: "@vpack/transformer-pii"
  - kind: chunker
    use: "@vpack/chunker-paragraph"
    min_size: 1
  - kind: transformer
    use: "@vpack/transformer-dedup"
    threshold: 0.98
  - kind: embedder
    use: "@vpack/embedder-xenova"
    provider: huggingface
    model: "Xenova/all-MiniLM-L6-v2"
    dimensions: 384
  - kind: output
    use: "@vpack/output-mcp"
    port: 3333
```

---

*This RFC is a living document. Discussion and amendments welcome via GitHub Issues and Pull Requests.*

*VectorPack is an open specification. Implementations are not required to be affiliated with the core project.*
