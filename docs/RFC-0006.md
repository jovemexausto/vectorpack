# RFC‑0006: Rust Acceleration Interfaces for Build and Query

**Status:** Draft  
**Version:** 0.1.0  
**Created:** 2026‑02‑27  
**Updated:** 2026‑02‑27  
**Authors:** VectorPack Contributors  

## Abstract
This RFC defines a Rust acceleration layer for VectorPack that preserves the TypeScript plugin ecosystem while offloading heavy compute tasks. Query performance is mandatory in Rust; build performance is mandatory in Rust for embedding, index construction, and serialization through a stable in‑process NAPI boundary. TypeScript plugins remain the authoring surface and unchanged. Optional Rust plugins are introduced as an opt‑in path for high‑performance use cases without requiring migration, with a default preference for Rust implementations when present.

## Motivation
VectorPack’s plugin ecosystem must remain TypeScript‑first for adoption and extensibility. However, vector math, indexing, and serialization are CPU‑heavy and benefit from Rust’s performance. We need a clear separation:

- **Keep**: TS plugin authoring (sources, transformers, chunkers, embedders, outputs).
- **Accelerate**: embedding batching, index building, serialization, and query execution.

The system should:
- Preserve existing TS plugin APIs.
- Avoid breaking the build pipeline contract.
- Provide a clean path for optional Rust plugins (implementation-level only).

## Goals
- Mandatory Rust engine for **query** performance.
- Mandatory Rust handlers for **build** performance (embed/index/serialize).
- Zero required migration for TS plugins.
- Stable error mapping to `VPackError` codes.
- Clear, minimal bridge contract between TS build and Rust.

## Non‑Goals
- Port all plugin types to Rust.
- Replace TypeScript plugin APIs.
- Introduce remote services or sidecar processes (in‑process NAPI only).
- Require WASM support in this phase.

## Terminology
- **Rust handler**: A Rust implementation of a heavy build step (embed, index, serialize).
- **TS plugin**: Existing TypeScript plugin code, unchanged.
- **Interop boundary**: NAPI interface between TS and Rust.

## Overview
The build pipeline remains TypeScript‑orchestrated. Heavy tasks are delegated to Rust via NAPI:

```
TS build pipeline:
  sources -> transformers -> chunker -> Rust embed -> Rust index build -> Rust serialize
```

Query runtime uses Rust only.

## Architecture

### 1) Rust Query Engine (Mandatory)
`@vpack/engine` uses Rust via NAPI for:
- vector search
- index query
- deserialization
- error codes

This is already implemented in the engine package.

### 2) Rust Build Handlers (Mandatory)
Introduce `@vpack/build-accelerator` (or extend `@vpack/engine` with build APIs) to handle:

- `embed(texts, embedder_config)` → vectors  
- `build_index(embedded_chunks, manifest)` → index  
- `serialize(index)` → `.vpack` bytes

The TS pipeline always calls Rust for these steps. TS plugins remain the authoring surface for sources/transformers/chunkers/embedders/outputs, but heavy compute is delegated to Rust handlers. When both TS and Rust embedder implementations exist, the build prefers Rust and falls back to TS if the Rust handler is unavailable.

### 3) Optional Rust Plugins (Opt‑In)
A plugin can provide a Rust handler in addition to its TS module:

```
@vpack/embedder-xenova
  - JS export (default): existing TS behavior
  - Rust handler (optional): registered by name
```

TS plugins remain the default authoring surface. Rust plugins are opt‑in and only affect the implementation of a given plugin's logic (not whether the build uses Rust handlers). The default resolution policy is: **prefer Rust if available**, otherwise use TS.

## Interop Contract

### 1) Data Transfer
- JSON for metadata and manifest
- Binary for vectors/index
- Use `Float32Array` for vectors from Rust to TS when feasible
- Batch embeddings to avoid unbounded memory growth on large corpora.

### 2) Error Mapping
Rust returns errors with stable `CODE|message` prefix. TS maps to `VPackError`.

### 3) Deterministic Serialization
Rust controls `.vpack` serialization (v0x02). TS format v0x01 is no longer supported for new builds.

## API Surface

### TypeScript
Add in `@vpack/build`:

```ts
export interface BuildAccelerationOptions {
  // Reserved for future use; build handlers are always Rust.
}
```

### Rust (NAPI)
Add exports:

- `embed(texts_json, config_json) -> vectors_json | error`
- `build_index(chunks_json, manifest_json) -> index_handle | error`
- `serialize_index(index_handle) -> bytes`
- `deserialize(bytes) -> index_handle`

### Rust Embedding (fastembed‑rs)
The first Rust embedder implementation uses `fastembed-rs` and is exposed as an optional Rust handler for embedders that support it. It must:
- Load models lazily and cache them per process.
- Enforce max batch sizes and chunk lengths to avoid memory spikes.
- Emit `f32` vectors with deterministic shape checks.

## Backward Compatibility
- Existing TS plugins continue to work unchanged.
- Build handlers (embed/index/serialize) always use Rust.
- Query always uses Rust engine.

## Performance Expectations
- Embedding: Rust batching improves throughput, avoids JS GC pressure.
- Index build: Rust is 2‑10x faster for large packs.
- Serialization: Rust is faster and deterministic.

## Security and Safety
- NAPI boundary must validate JSON payloads.
- Large payloads handled with streaming or chunked buffers in future iterations.

## Rollout Plan
1. Implement NAPI build handlers in Rust engine.
2. Expose build acceleration interfaces in `@vpack/build`.
3. Add `fastembed-rs` as the first opt‑in Rust embedder implementation.
4. Document defaults and migration path.
5. Benchmark and adjust defaults.

## Test Plan
- Unit tests for error mapping.
- Integration tests: build pipeline uses Rust handlers; TS plugins unchanged.
- Regression tests for `.vpack` read/write.

## Open Questions
- How should TS plugins declare optional Rust implementations?
- Do we need a registry of Rust handler implementations beyond embedder plugins?
