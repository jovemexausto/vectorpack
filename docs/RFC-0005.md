# RFC-0005: Incremental Patch Distribution with Snapshot Integrity

**Status:** Draft  
**Version:** 0.1.0  
**Created:** 2026-02-27  
**Updated:** 2026-02-27  
**Authors:** VectorPack Contributors  
**Depends on:** RFC-0001 v0.3.0, RFC-0003 v0.1.0 (Det-IVF-PQ), RFC-0004 v0.1.0 (Temporal Knowledge)

### Changelog

- **0.1.0** — Initial draft.

---

## Abstract

This RFC specifies **Incremental Patch Distribution** — a mechanism for delivering updates to VectorPack artifacts using small, verifiable `.vpack.patch` files instead of full snapshots on every rebuild, while **preserving the single-bundle invariant** as the canonical, queryable unit of knowledge.

Patches are treated as an **ephemeral transport optimization**. Every application of a patch results in a single, self-contained `.vpack` file that is byte-identical to what a full rebuild would have produced. Consumers and adapters never interact with patch chains directly; they always work against one unified artifact.

The design guarantees **snapshot integrity**: patches can only be applied to the exact base they were generated against, and the result is cryptographically verifiable against a known hash. This enables efficient subscription workflows without fragmenting the user experience or breaking the core promise of a portable, single-file knowledge artifact.

---

## Table of Contents

1. [Motivation](#1-motivation)
2. [Core Principles](#2-core-principles)
3. [The .vpack.patch Artifact Format](#3-the-vpackpatch-artifact-format)
4. [Patch Application Semantics](#4-patch-application-semantics)
5. [Registry Protocol Extensions](#5-registry-protocol-extensions)
6. [CLI Commands for Patch Management](#6-cli-commands-for-patch-management)
7. [Adapter Behavior](#7-adapter-behavior)
8. [Compaction and Chain Bounding](#8-compaction-and-chain-bounding)
9. [Fallback and Safety Guarantees](#9-fallback-and-safety-guarantees)
10. [Manifest Configuration](#10-manifest-configuration)
11. [Security Considerations](#11-security-considerations)
12. [Open Questions](#12-open-questions)

---

## 1. Motivation

Frequent rebuilds of large knowledge packs create bandwidth, storage, and latency problems:

- A nightly rebuild of a 500 MB pack wastes 15 GB/month if every consumer redownloads the full artifact.
- Temporal packs (RFC-0004) accumulate history, making full snapshots even larger over time.
- Many changes are incremental (a few documents updated, one new policy added), yet consumers pay the full cost.

Patch distribution solves this by sending only deltas. However, raw patch chains risk turning a simple format into a fragmented, git-like repository that complicates UX and breaks the “single artifact” promise.

This RFC resolves the tension: **patches are real, but invisible**. They improve distribution efficiency without changing how most users or tools interact with VectorPack.

---

## 2. Core Principles

1. **Single artifact is canonical**  
   The queryable, portable unit is always one `.vpack` file. Patches are never the primary interface.

2. **Patches are transport-only**  
   Applying a patch produces an updated single `.vpack`. The patch file is discarded after successful application.

3. **Deterministic result guarantee**  
   A patched artifact must be byte-identical (same manifest_hash, same section hashes) to a full rebuild from the same inputs.

4. **Atomic & verifiable application**  
   Patch application is all-or-nothing. Base and result hashes are checked. Failure → discard patch, fallback to full snapshot.

5. **Opt-in & progressive disclosure**  
   Most users never see or manage patches. Power users / long-running agents opt in via flags or subscription mode.

6. **No chain awareness in queries**  
   Adapters and the engine never traverse patch chains. They load one unified bundle.

---

## 3. The .vpack.patch Artifact Format

A `.vpack.patch` is a standalone binary file with the following layout:

```
┌─────────────────────────────────────────────┐
│  PATCH HEADER (fixed 64 bytes)              │
│  magic:               b"VPATCH"             │
│  spec_version:        u8                    │
│  flags:               u16                   │
│  base_pack_hash:      [u8; 32]              │  ← manifest_hash of base artifact
│  result_pack_hash:    [u8; 32]              │  ← manifest_hash after apply
│  patch_id:            [u8; 16]              │  ← UUID for logging/tracking
├─────────────────────────────────────────────┤
│  SECTION TABLE (variable)                   │
│  [ section_id: u8, offset: u64, length: u64, checksum: u32 ] × N
├─────────────────────────────────────────────┤
│  SECTION: CHUNK_DIFFS          (0x01)       │
│  added:   Vec<EmbeddedChunk>                │
│  modified: Vec<(old_chunk_id: string, new: EmbeddedChunk)>
│  removed: Vec<string>                       │  ← chunk IDs only
├─────────────────────────────────────────────┤
│  SECTION: INDEX_PATCH          (0x02)       │  present iff index.type = ivf-pq
│  affected_clusters: Vec<u32>                │
│  cluster_deltas: Vec<ClusterDelta>          │  (added/removed PQ codes + node_ids, sorted)
├─────────────────────────────────────────────┤
│  SECTION: CHANGELOG_ENTRY      (0x03)       │
│  entry: ChangelogChunk                      │  pre-embedded, from output-diff-summary
└─────────────────────────────────────────────┘
```

- All sections are optional except the header.
- `ClusterDelta` format is specified in RFC-0003 §11 (Q4 resolution).
- Checksums are SHA-256 of each section content.
- File is small (typically 1–15% of full pack size for incremental changes).

---

## 4. Patch Application Semantics

Application is atomic and produces a new single `.vpack`:

1. Verify `base_pack_hash` matches local artifact's manifest_hash.
2. Stage updated CHUNKS (0x02) and VECTORS (0x03) from CHUNK_DIFFS.
3. If INDEX_PATCH present (IVF-PQ):
   - Load existing INDEX (0x04)
   - For each affected cluster: merge sorted delta into inverted list
4. If no INDEX_PATCH (fallback or other index types): rebuild INDEX from staged CHUNKS+VECTORS.
5. Append CHANGELOG_ENTRY to CHANGELOG (0x06) section (create if missing).
6. Update header: increment section_count if CHANGELOG was new, update flags.
7. Compute new manifest_hash of staged artifact.
8. Verify it matches `result_pack_hash`.
9. Atomically replace local `.vpack` file (rename staging file).
10. Delete patch file.

Failure at any step (hash mismatch, I/O error, invalid delta) → discard staging, log error, fallback to full pull.

---

## 5. Registry Protocol Extensions

New endpoints (all under `/v1/packs/{scope}/{name}/{version}`):

- `GET /patches?since={version_or_hash}`  
  → `{ patches: [{from, to, hash, size}], catch_up_required: bool }`

- `GET /patches/{patch_hash}`  
  → binary .vpack.patch

- `GET /snapshots/{version}`  
  → full .vpack (always available, cached)

- `POST /verify-patch` (optional)  
  Body: `{ base_hash, patch_hash }`  
  → `{ valid: bool, expected_result_hash: string }`

Registry stores patches content-addressed; never overwrites immutable artifacts.

---

## 6. CLI Commands for Patch Management

New verbs keep DX clean and git-like:

```bash
# One-time full pull (default behavior)
vpack pull @acme/knowledge:latest

# Start incremental subscription (creates ~/.vpackrc entry)
vpack subscribe @acme/knowledge --auto-apply --compact-after 15

# Manually check + apply pending patches
vpack update @acme/knowledge

# Force full snapshot (breaks incremental chain)
vpack pull @acme/knowledge:latest --force-snapshot

# Apply standalone patch (debug / offline)
vpack apply ./knowledge-3.14.1.vpack.patch --to ./knowledge.vpack

# Compact chain into new snapshot
vpack compact @acme/knowledge --keep-patches 5

# See subscription status
vpack status @acme/knowledge
```

All commands default to producing/maintaining a single `.vpack` file.

---

## 7. Adapter Behavior

Adapters abstract patching away:

```typescript
// Default: snapshot semantics
const index = await load("@acme/knowledge:latest");

// Opt-in to incremental (background patch polling + apply)
const index = await load("@acme/knowledge:latest", {
  incremental: true,
  autoCompact: 15,           // patches
  localPath: "./knowledge.vpack"
});

// Explicit patch apply (rare / advanced)
await index.applyPatch(patchBytes);
```

The loaded `index` is always backed by one unified `.vpack`. No chain traversal in query path.

---

## 8. Compaction and Chain Bounding

When patch chain grows too long:

- Registry signals `catch_up_required: true` after threshold (default: 30 patches)
- CLI `vpack compact` fetches missing patches, applies all, produces new snapshot
- Manifest can set `max_patch_chain: 20` — registry forces snapshot beyond this

Compaction may optionally re-cluster Det-IVF-PQ for better query performance after many small updates.

---

## 9. Fallback and Safety Guarantees

- Hash mismatch → immediate full pull
- Patch unavailable → full snapshot
- Apply interrupted → local artifact unchanged
- Registry offline → use cached snapshot + cached patches
- Non-temporal packs ignore CHANGELOG_ENTRY in patches

No partial states are ever exposed to queries.

---

## 10. Manifest Configuration

```yaml
publish:
  incremental: true             # default false
  max_patch_chain: 30
  compact_threshold_mb: 50      # force snapshot if patch would exceed this size
```

Enables/disables patch generation in `@vpack/output-registry`.

---

## 11. Security Considerations

- **Hash chain immutability** — base → result hashes prevent replay or out-of-order attacks.
- **Patch authenticity** — registry signs patch metadata (future extension).
- **No execution risk** — patches contain only data (chunks, PQ codes), no code/plugins.
- **Size DoS** — registry rejects patches > configured % of base size.

---

## 12. Open Questions

**Q1: Auto-compact aggressiveness.** Default 15 patches — too low? Too high for mobile/edge?

**Q2: Partial section patching.** Should CHUNKS/VECTORS support delta encoding (e.g., only changed rows) instead of full Vec?

**Q3: Patch signing.** Registry-generated signature over patch + base/result hashes?

**Q4: Offline-first subscribe.** How should long-offline clients efficiently catch up (e.g., batched patch bundles)?

**Q5: Size estimation in registry.** Should registry pre-compute patch size and reject oversized deltas early?

---

*This RFC is a living document. Discussion and amendments welcome via GitHub Issues and Pull Requests.*

*VectorPack is an open specification. Implementations are not required to be affiliated with the core project.*
